{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Developing Sitodo From Zero A training course for developing a simple todo list Web application using Java and Spring Boot framework. Description This is a training course for teaching students on how to develop a Web application using Java programming language and Spring Boot framework, with focus on applying test-first approach and continuous integration/continuous deployment (CI/CD). Learning Outcomes By the end of this course, students should be able to: Apply a workflow when using a version control system such as Git Develop a simple Web application using Java programming language and Spring Boot framework backed by a relational database. Create tests for verifying the Web application in different levels, such as unit test, integration test, and functional test Set up a Continuous Integration/Continuous Deployment (CI/CD) pipeline using GitHub Actions (or similar platform such as GitLab CI/CD) Target Audience While the course is designed for fresh graduates with a background in computing, students coming from a different background can read and attend the course. At minimum, you need to: Have some experiences in programming, preferably using an object-oriented language Understand relational data modeling and SQL operations Know Web design and familiar with the related technologies such as HTML, basic JavaScript, and CSS Know basic Linux shell scripting (e.g. bash ) or its equivalent on Windows (e.g. cmd or pwsh ) Requirements To complete this course, you need a computing device that can run the following development tools: A shell, such as bash on Linux or Mac OS, or cmd / pwsh on Windows Latest long-term support (LTS) version (i.e. Java 17 at the time of writing) of Java Development Kit (JDK), preferably from Adoptium . IntelliJ IDEA Community Edition by JetBrains PostgreSQL database system version 14 Note: While you can use other text editors (e.g. Visual Studio Code) or IDE such as Eclipse or NetBeans, we might not be able to troubleshoot any problems that come up during the course In addition, you also need to have an account on the following online services: GitHub an online source code repository and project management system Heroku a Platform-as-a-Service (PaaS) for deploying the Web application Course Outlines The course will include: Set up local development environment Initialise up a Spring Boot project Introduction to test-driven development (TDD) Create a continuous integration and deployment pipeline (CI/CD) Exercise a Git workflow such as Feature Branch There will be some additional challenges for participants, such as: Develop functional test using Selenium Implement basic user authentication using Spring Security Migrate deployment to a different PaaS provider such as Fly.io You can proceed to the contents for Day 1 . License The learning materials in this course are licensed under Creative Commons Attribution-ShareAlike 4.0 ( CC BY-SA 4.0 ). You can reuse, modify, distribute, and do pretty much anything with the course materials as long as it is permitted under the terms of the license.","title":"Course Overview"},{"location":"#developing-sitodo-from-zero","text":"A training course for developing a simple todo list Web application using Java and Spring Boot framework.","title":"Developing Sitodo From Zero"},{"location":"#description","text":"This is a training course for teaching students on how to develop a Web application using Java programming language and Spring Boot framework, with focus on applying test-first approach and continuous integration/continuous deployment (CI/CD).","title":"Description"},{"location":"#learning-outcomes","text":"By the end of this course, students should be able to: Apply a workflow when using a version control system such as Git Develop a simple Web application using Java programming language and Spring Boot framework backed by a relational database. Create tests for verifying the Web application in different levels, such as unit test, integration test, and functional test Set up a Continuous Integration/Continuous Deployment (CI/CD) pipeline using GitHub Actions (or similar platform such as GitLab CI/CD)","title":"Learning Outcomes"},{"location":"#target-audience","text":"While the course is designed for fresh graduates with a background in computing, students coming from a different background can read and attend the course. At minimum, you need to: Have some experiences in programming, preferably using an object-oriented language Understand relational data modeling and SQL operations Know Web design and familiar with the related technologies such as HTML, basic JavaScript, and CSS Know basic Linux shell scripting (e.g. bash ) or its equivalent on Windows (e.g. cmd or pwsh )","title":"Target Audience"},{"location":"#requirements","text":"To complete this course, you need a computing device that can run the following development tools: A shell, such as bash on Linux or Mac OS, or cmd / pwsh on Windows Latest long-term support (LTS) version (i.e. Java 17 at the time of writing) of Java Development Kit (JDK), preferably from Adoptium . IntelliJ IDEA Community Edition by JetBrains PostgreSQL database system version 14 Note: While you can use other text editors (e.g. Visual Studio Code) or IDE such as Eclipse or NetBeans, we might not be able to troubleshoot any problems that come up during the course In addition, you also need to have an account on the following online services: GitHub an online source code repository and project management system Heroku a Platform-as-a-Service (PaaS) for deploying the Web application","title":"Requirements"},{"location":"#course-outlines","text":"The course will include: Set up local development environment Initialise up a Spring Boot project Introduction to test-driven development (TDD) Create a continuous integration and deployment pipeline (CI/CD) Exercise a Git workflow such as Feature Branch There will be some additional challenges for participants, such as: Develop functional test using Selenium Implement basic user authentication using Spring Security Migrate deployment to a different PaaS provider such as Fly.io You can proceed to the contents for Day 1 .","title":"Course Outlines"},{"location":"#license","text":"The learning materials in this course are licensed under Creative Commons Attribution-ShareAlike 4.0 ( CC BY-SA 4.0 ). You can reuse, modify, distribute, and do pretty much anything with the course materials as long as it is permitted under the terms of the license.","title":"License"},{"location":"toc/","text":"Table of Contents Course Setup Install Git Reminder about newlines, i.e. git config --global auto.crlf input , and install EditorConfig Install Java Ensure JAVA_HOME and PATH configured properly Install IDE (IntelliJ) Set up GitHub account Set up Heroku / Fly.io account At the end, verify all tools have been installed, e.g. git --version Project Scaffolding Use Spring Initializr Initialise Git repository in local development environment Create a new online Git repository on GitHub Update README.md Create a first commit Set up a new Git remote from local repository to online repository on GitHub Push local Git history to the online repository Implement Landing Page (Hello, World) Introduction to test-driven development (TDD) Inside-out TDD part 1: pure unit test Create an HTML page for the landing page with custom greeting from GET request Create a unit test for the controller class Inside-out TDD part 2: unit test in mocked environment using @MockMvc and @SpringBootTest Create a unit test with mock for the controller class Inside-out TDD part 3: functional test with Selenium (Optional) Quality Assurance & Test Automation Deploy the app manually using Heroku or Fly.io CLI tool Automate test suite execution using GitHub Actions on GitHub Automate deployment using GitHub Actions on GitHub Code quality analysis using GitHub Actions on GitHub (Optional) Implement Todo List Implement data persistence layer Create model class using JPA Create migration script using Liquibase Implement business logic layer Create a service class Write a unit test for service class Implement presentation layer Create a controller class Write a unit test for controller class Create a Web page using HTML and Thymeleaf template syntax Extra Challenge: Personalised Todo List with Authentication Define user authentication model Update database schema via database migration Secure the existing todo list behind authentication Extra Challenge: PostgreSQL Database Install PostgreSQL on development and deployment environments Local installation options: system-wide (using installer) or container (Docker) Installation options on PaaS: Heroku Addon (Heroku) or flyctl (Fly.io)","title":"Table of Contents"},{"location":"toc/#table-of-contents","text":"","title":"Table of Contents"},{"location":"toc/#course-setup","text":"Install Git Reminder about newlines, i.e. git config --global auto.crlf input , and install EditorConfig Install Java Ensure JAVA_HOME and PATH configured properly Install IDE (IntelliJ) Set up GitHub account Set up Heroku / Fly.io account At the end, verify all tools have been installed, e.g. git --version","title":"Course Setup"},{"location":"toc/#project-scaffolding","text":"Use Spring Initializr Initialise Git repository in local development environment Create a new online Git repository on GitHub Update README.md Create a first commit Set up a new Git remote from local repository to online repository on GitHub Push local Git history to the online repository","title":"Project Scaffolding"},{"location":"toc/#implement-landing-page-hello-world","text":"Introduction to test-driven development (TDD) Inside-out TDD part 1: pure unit test Create an HTML page for the landing page with custom greeting from GET request Create a unit test for the controller class Inside-out TDD part 2: unit test in mocked environment using @MockMvc and @SpringBootTest Create a unit test with mock for the controller class Inside-out TDD part 3: functional test with Selenium (Optional)","title":"Implement Landing Page (Hello, World)"},{"location":"toc/#quality-assurance-test-automation","text":"Deploy the app manually using Heroku or Fly.io CLI tool Automate test suite execution using GitHub Actions on GitHub Automate deployment using GitHub Actions on GitHub Code quality analysis using GitHub Actions on GitHub (Optional)","title":"Quality Assurance &amp; Test Automation"},{"location":"toc/#implement-todo-list","text":"Implement data persistence layer Create model class using JPA Create migration script using Liquibase Implement business logic layer Create a service class Write a unit test for service class Implement presentation layer Create a controller class Write a unit test for controller class Create a Web page using HTML and Thymeleaf template syntax","title":"Implement Todo List"},{"location":"toc/#extra-challenge-personalised-todo-list-with-authentication","text":"Define user authentication model Update database schema via database migration Secure the existing todo list behind authentication","title":"Extra Challenge: Personalised Todo List with Authentication"},{"location":"toc/#extra-challenge-postgresql-database","text":"Install PostgreSQL on development and deployment environments Local installation options: system-wide (using installer) or container (Docker) Installation options on PaaS: Heroku Addon (Heroku) or flyctl (Fly.io)","title":"Extra Challenge: PostgreSQL Database"},{"location":"bootcamp/day-1/","text":"Bootcamp (Day 1) Still in development. Stay tune!","title":"Bootcamp (Day 1)"},{"location":"bootcamp/day-1/#bootcamp-day-1","text":"Still in development. Stay tune!","title":"Bootcamp (Day 1)"},{"location":"bootcamp/day-1/basic-list/","text":"Create a Basic Todo List Data Persistence Layer Create a new class named TodoItem in the production code, specifically in a new package named model : import lombok.Data; import lombok.NoArgsConstructor; import javax.persistence.*; @Data @Entity @NoArgsConstructor public class TodoItem { @Id @GeneratedValue(strategy = GenerationType.SEQUENCE) private Long id; @Column(nullable = false) private String title; @Column private Boolean finished = Boolean.FALSE; public TodoItem(String title) { this.title = title; } public TodoItem(Long id, String title) { this.id = id; this.title = title; } } Repository Layer Create a new Java interface named TodoListRepository that extends CrudRepository interface provided by Spring JPA. Put the new Java interface in a new package called repository in the production code. We will use it to implement a data access layer in between the data model and business logic layers. The TodoListRepository implementation is short and can be seen in the following code snippet: // Removed some import statements for brevity. import org.springframework.data.repository.CrudRepository; import org.springframework.stereotype.Repository; @Repository public interface TodoListRepository extends CrudRepository<TodoItem, Long> { } Service Layer Create a new package called service in the production code. Then, create a new class named TodoListService in the new package. We will use service package to contain classes related to service layer of the app, i.e. classes that provide implementations related to business logic. The content of TodoListService is as follows: // Removed some import statements for brevity. import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Service; import java.util.List; @Service public class TodoListService { private TodoListRepository todoListRepository; @Autowired public void setTodoListRepository(TodoListRepository todoListRepository) { this.todoListRepository = todoListRepository; } } Since we will implement a basic todo list that shows a list of todo items, we need to implement methods that can add and retrieve todo items: public class TodoListService { // Omitted for brevity private TodoListRepository todoListRepository; public List<TodoItem> getTodoItems() { return todoListRepository.findAll(); } public TodoItem addTodoItem(TodoItem todoItem) { return todoListRepository.save(todoItem); } } Test Initial Implementation You might question: \"Do we need to test the repository and service classes?\" The implementation of both layers is quite simple at this point, so one might wonder if it is worth testing them. The repository layer can be left untested at the moment because we did not customise the inherited implementation. The service layer, however, needs to be tested because it is related to business logic that is domain-specific to the problem. Create a new class named TodoListService in the test code and ensure the package structure follows the production code. In the new class, implement the test cases that verify the expected correct behaviour of both getTodoItems and addTodoItem : import com.example.sitodo.model.TodoItem; import com.example.sitodo.repository.TodoListRepository; import org.junit.jupiter.api.Test; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.context.SpringBootTest; import org.springframework.boot.test.mock.mockito.MockBean; import static org.mockito.ArgumentMatchers.any; import static org.mockito.Mockito.when; @SpringBootTest class TodoListServiceTest { @Autowired private TodoListService todoListService; @MockBean private TodoListRepository todoListRepository; @Test void getTodoItems_someItems_ok() { when(todoListRepository.findAll()).thenReturn(List.of( new TodoItem(\"A\"), new TodoItem(\"B\"), new TodoItem(\"C\") )); List<TodoItem> todoItems = todoListService.findAll(); assertEquals(3, todoItems.size()); } @Test void addTodoItem_ok() { TodoItem todoItem = new TodoItem(\"Buy milk\"); when(todoListRepository.save(any(TodoItem.class))).thenReturn(todoItem); TodoItem savedTodoItem = todoListService.addTodoItem(todoItem); assertEquals(\"Buy milk\", savedTodoItem.getTitle()); } } Maybe you noticed that the tests look different from the one you created in the previous section. The tests above implement a mock object that serves as a stand-in of an actual object during testing. The mock object can be configured to simulate a behaviour specific during testing. We use a mock object to ensure the test in the service layer is independent of the repository layer. Back to Controller and View You have implemented the business logic of adding and listing a todo list. The next step is to implement the controller to handle requests from the user. But before that, in spirit of TDD, let us create a test first. Let us start by implementing a method to retrieve the todo list. Create a new class named TodoListControllerTest in the test code: You know where to put it, right? Controller classes go into controller package. Maintain proper separation of concern in your codebase! // Removed some import statements for brevity. import org.junit.jupiter.api.Test; import org.junit.jupiter.api.DisplayName; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest; import org.springframework.boot.test.mock.mockito.MockBean; import org.springframework.test.web.servlet.MockMvc; import static java.nio.charset.StandardCharsets.UTF_8; import static org.hamcrest.Matchers.*; import static org.mockito.ArgumentMatchers.anyBoolean; import static org.mockito.ArgumentMatchers.anyLong; import static org.mockito.Mockito.mock; import static org.mockito.Mockito.when; import static org.springframework.http.MediaType.TEXT_HTML; import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get; import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*; @WebMvcTest(TodoListController.class) @Tag(\"unit\") class TodoListControllerTest { @Autowired private MockMvc mockMvc; @MockBean private TodoListService todoListService; // New annotation! // @DisplayName allows you to customise the name of a test case. @Test @DisplayName(\"HTTP GET '/list' retrieves list view\") void showList_correctView() throws Exception { mockMvc.perform(get(\"/list\")).andExpectAll( status().isOk(), content().contentTypeCompatibleWith(TEXT_HTML), content().encoding(UTF_8), view().name(\"list\") ); } @Test @DisplayName(\"HTTP GET '/list' returns an HTML page\") void showList_returnHtml() throws Exception { mockMvc.perform(get(\"/list\")).andExpectAll( status().isOk(), content().contentTypeCompatibleWith(TEXT_HTML), content().encoding(UTF_8), content().string(containsString(\"</html>\")) ); } @Test @DisplayName(\"HTTP GET '/list' returns an HTML page with non-empty list\") void showList_withSampleData_ok() throws Exception { TodoItem mockTodoItem = new TodoItem(\"Buy milk\"); when(todoListService.getTodoItems()).thenReturn(List.of(mockTodoItem)); mockMvc.perform(get(\"/list\")).andExpectAll( status().isOk(), content().contentTypeCompatibleWith(TEXT_HTML), content().encoding(UTF_8), content().string(containsString(\"Buy milk\")) ); } } Implement the actual controller in the production code: // Removed import statements for brevity @Controller public class TodoListController { private TodoListService todoListService; @Autowired public void setTodoListService(TodoListService todoListService) { this.todoListService = todoListService; } @GetMapping(\"/list\") public String showList(Model model) { List<TodoItem> todoItems = todoListService.getTodoItems(); model.add(\"todoList\", todoItems); return \"list\"; } } Do not forget to create the HTML view of the todo list. Create a new HTML view called list.html in templates directory at src/main/resources : <!doctype html> <html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\"> <head> <meta charset=\"utf-8\"/> <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"/> <link th:rel=\"stylesheet\" th:href=\"@{/webjars/bootstrap/5.1.3/dist/css/bootstrap.css}\"/> <title>Sitodo</title> </head> <body> <div class=\"container\"> <header class=\"d-flex flex-wrap justify-content-center py-3 mb-4 border-bottom\"> <span class=\"fs-4\">SITODO</span> </header> <table id=\"id_list_table\" class=\"table caption-top\"> <caption class=\"display-1\">Your Todo List</caption> <thead class=\"table-dark\"> <tr> <th scope=\"col\">ID</th> <th scope=\"col\">Title</th> <th scope=\"col\">Status</th> </tr> </thead> <tbody> <tr th:each=\"item : ${todoList}\"> <td th:text=\"${item.id}\">1</td> <td th:text=\"${item.title}\">Cook rice</td> <td th:text=\"${item.finished} ? 'Finished' : 'Not Finished'\">Not Finished</td> </tr> </tbody> </table> <form action=\"/list\" method=\"post\"> <input type=\"text\" id=\"id_new_item\" name=\"item_text\" placeholder=\"Enter an item\"/> <button type=\"submit\" class=\"btn btn-primary btn-sm\">Enter</button> </form> </div> <script th:src=\"@{/webjars/bootstrap/5.1.3/dist/js/bootstrap.bundle.js}\"></script> </body> </html> The HTML view example above requires the Bootstrap CSS framework . You can either include Bootstrap from a content delivery network (CDN), or add a new dependency in pom.xml that adds Bootstrap into the project. If you choose to update the project dependencies in pom.xml , use the following Maven dependency that includes Bootstrap: <dependency> <groupId>org.webjars.npm</groupId> <artifactId>bootstrap</artifactId> <version>5.1.3</version> </dependency> Complete the Basic Functionality You have known the overall groundwork required to implement a feature in the TDD approach. The next task is to ensure the user can actually create a new todo item. Now try to work on your own. But do not worry, there will be hints on how to complete it. Your tasks are as follows: Add a new test case in TodoListControllerTest that verifies the correctness of incoming HTTP POST message. Try to figure out how to use MockMvc to simulate an HTTP POST message with a data payload (i.e. the new todo item submitted via an HTML form). Add a new method in TodoListController that handles incoming HTTP POST message containing the new todo item. Use @PostMapping annotation to designate the new method as the handler of an incoming HTTP POST message to /list path. You also need to add a parameter into the method, so you can obtain the new todo item in the HTTP POST message. Try to run the application from time to time. While having test suites that are executed by a test runner is important, do not forget to run the app manually and try using it as an actual user. You can run the app by executing main() method in SitodoApplication class, or by calling mvnw spring-boot:run Maven command. If you have finished, do not forget to save your latest work as a commit and push it to GitHub: git add <path to the changed files> git commit git push","title":"Create a Basic Todo List"},{"location":"bootcamp/day-1/basic-list/#create-a-basic-todo-list","text":"","title":"Create a Basic Todo List"},{"location":"bootcamp/day-1/basic-list/#data-persistence-layer","text":"Create a new class named TodoItem in the production code, specifically in a new package named model : import lombok.Data; import lombok.NoArgsConstructor; import javax.persistence.*; @Data @Entity @NoArgsConstructor public class TodoItem { @Id @GeneratedValue(strategy = GenerationType.SEQUENCE) private Long id; @Column(nullable = false) private String title; @Column private Boolean finished = Boolean.FALSE; public TodoItem(String title) { this.title = title; } public TodoItem(Long id, String title) { this.id = id; this.title = title; } }","title":"Data Persistence Layer"},{"location":"bootcamp/day-1/basic-list/#repository-layer","text":"Create a new Java interface named TodoListRepository that extends CrudRepository interface provided by Spring JPA. Put the new Java interface in a new package called repository in the production code. We will use it to implement a data access layer in between the data model and business logic layers. The TodoListRepository implementation is short and can be seen in the following code snippet: // Removed some import statements for brevity. import org.springframework.data.repository.CrudRepository; import org.springframework.stereotype.Repository; @Repository public interface TodoListRepository extends CrudRepository<TodoItem, Long> { }","title":"Repository Layer"},{"location":"bootcamp/day-1/basic-list/#service-layer","text":"Create a new package called service in the production code. Then, create a new class named TodoListService in the new package. We will use service package to contain classes related to service layer of the app, i.e. classes that provide implementations related to business logic. The content of TodoListService is as follows: // Removed some import statements for brevity. import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Service; import java.util.List; @Service public class TodoListService { private TodoListRepository todoListRepository; @Autowired public void setTodoListRepository(TodoListRepository todoListRepository) { this.todoListRepository = todoListRepository; } } Since we will implement a basic todo list that shows a list of todo items, we need to implement methods that can add and retrieve todo items: public class TodoListService { // Omitted for brevity private TodoListRepository todoListRepository; public List<TodoItem> getTodoItems() { return todoListRepository.findAll(); } public TodoItem addTodoItem(TodoItem todoItem) { return todoListRepository.save(todoItem); } }","title":"Service Layer"},{"location":"bootcamp/day-1/basic-list/#test-initial-implementation","text":"You might question: \"Do we need to test the repository and service classes?\" The implementation of both layers is quite simple at this point, so one might wonder if it is worth testing them. The repository layer can be left untested at the moment because we did not customise the inherited implementation. The service layer, however, needs to be tested because it is related to business logic that is domain-specific to the problem. Create a new class named TodoListService in the test code and ensure the package structure follows the production code. In the new class, implement the test cases that verify the expected correct behaviour of both getTodoItems and addTodoItem : import com.example.sitodo.model.TodoItem; import com.example.sitodo.repository.TodoListRepository; import org.junit.jupiter.api.Test; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.context.SpringBootTest; import org.springframework.boot.test.mock.mockito.MockBean; import static org.mockito.ArgumentMatchers.any; import static org.mockito.Mockito.when; @SpringBootTest class TodoListServiceTest { @Autowired private TodoListService todoListService; @MockBean private TodoListRepository todoListRepository; @Test void getTodoItems_someItems_ok() { when(todoListRepository.findAll()).thenReturn(List.of( new TodoItem(\"A\"), new TodoItem(\"B\"), new TodoItem(\"C\") )); List<TodoItem> todoItems = todoListService.findAll(); assertEquals(3, todoItems.size()); } @Test void addTodoItem_ok() { TodoItem todoItem = new TodoItem(\"Buy milk\"); when(todoListRepository.save(any(TodoItem.class))).thenReturn(todoItem); TodoItem savedTodoItem = todoListService.addTodoItem(todoItem); assertEquals(\"Buy milk\", savedTodoItem.getTitle()); } } Maybe you noticed that the tests look different from the one you created in the previous section. The tests above implement a mock object that serves as a stand-in of an actual object during testing. The mock object can be configured to simulate a behaviour specific during testing. We use a mock object to ensure the test in the service layer is independent of the repository layer.","title":"Test Initial Implementation"},{"location":"bootcamp/day-1/basic-list/#back-to-controller-and-view","text":"You have implemented the business logic of adding and listing a todo list. The next step is to implement the controller to handle requests from the user. But before that, in spirit of TDD, let us create a test first. Let us start by implementing a method to retrieve the todo list. Create a new class named TodoListControllerTest in the test code: You know where to put it, right? Controller classes go into controller package. Maintain proper separation of concern in your codebase! // Removed some import statements for brevity. import org.junit.jupiter.api.Test; import org.junit.jupiter.api.DisplayName; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest; import org.springframework.boot.test.mock.mockito.MockBean; import org.springframework.test.web.servlet.MockMvc; import static java.nio.charset.StandardCharsets.UTF_8; import static org.hamcrest.Matchers.*; import static org.mockito.ArgumentMatchers.anyBoolean; import static org.mockito.ArgumentMatchers.anyLong; import static org.mockito.Mockito.mock; import static org.mockito.Mockito.when; import static org.springframework.http.MediaType.TEXT_HTML; import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get; import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*; @WebMvcTest(TodoListController.class) @Tag(\"unit\") class TodoListControllerTest { @Autowired private MockMvc mockMvc; @MockBean private TodoListService todoListService; // New annotation! // @DisplayName allows you to customise the name of a test case. @Test @DisplayName(\"HTTP GET '/list' retrieves list view\") void showList_correctView() throws Exception { mockMvc.perform(get(\"/list\")).andExpectAll( status().isOk(), content().contentTypeCompatibleWith(TEXT_HTML), content().encoding(UTF_8), view().name(\"list\") ); } @Test @DisplayName(\"HTTP GET '/list' returns an HTML page\") void showList_returnHtml() throws Exception { mockMvc.perform(get(\"/list\")).andExpectAll( status().isOk(), content().contentTypeCompatibleWith(TEXT_HTML), content().encoding(UTF_8), content().string(containsString(\"</html>\")) ); } @Test @DisplayName(\"HTTP GET '/list' returns an HTML page with non-empty list\") void showList_withSampleData_ok() throws Exception { TodoItem mockTodoItem = new TodoItem(\"Buy milk\"); when(todoListService.getTodoItems()).thenReturn(List.of(mockTodoItem)); mockMvc.perform(get(\"/list\")).andExpectAll( status().isOk(), content().contentTypeCompatibleWith(TEXT_HTML), content().encoding(UTF_8), content().string(containsString(\"Buy milk\")) ); } } Implement the actual controller in the production code: // Removed import statements for brevity @Controller public class TodoListController { private TodoListService todoListService; @Autowired public void setTodoListService(TodoListService todoListService) { this.todoListService = todoListService; } @GetMapping(\"/list\") public String showList(Model model) { List<TodoItem> todoItems = todoListService.getTodoItems(); model.add(\"todoList\", todoItems); return \"list\"; } } Do not forget to create the HTML view of the todo list. Create a new HTML view called list.html in templates directory at src/main/resources : <!doctype html> <html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\"> <head> <meta charset=\"utf-8\"/> <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"/> <link th:rel=\"stylesheet\" th:href=\"@{/webjars/bootstrap/5.1.3/dist/css/bootstrap.css}\"/> <title>Sitodo</title> </head> <body> <div class=\"container\"> <header class=\"d-flex flex-wrap justify-content-center py-3 mb-4 border-bottom\"> <span class=\"fs-4\">SITODO</span> </header> <table id=\"id_list_table\" class=\"table caption-top\"> <caption class=\"display-1\">Your Todo List</caption> <thead class=\"table-dark\"> <tr> <th scope=\"col\">ID</th> <th scope=\"col\">Title</th> <th scope=\"col\">Status</th> </tr> </thead> <tbody> <tr th:each=\"item : ${todoList}\"> <td th:text=\"${item.id}\">1</td> <td th:text=\"${item.title}\">Cook rice</td> <td th:text=\"${item.finished} ? 'Finished' : 'Not Finished'\">Not Finished</td> </tr> </tbody> </table> <form action=\"/list\" method=\"post\"> <input type=\"text\" id=\"id_new_item\" name=\"item_text\" placeholder=\"Enter an item\"/> <button type=\"submit\" class=\"btn btn-primary btn-sm\">Enter</button> </form> </div> <script th:src=\"@{/webjars/bootstrap/5.1.3/dist/js/bootstrap.bundle.js}\"></script> </body> </html> The HTML view example above requires the Bootstrap CSS framework . You can either include Bootstrap from a content delivery network (CDN), or add a new dependency in pom.xml that adds Bootstrap into the project. If you choose to update the project dependencies in pom.xml , use the following Maven dependency that includes Bootstrap: <dependency> <groupId>org.webjars.npm</groupId> <artifactId>bootstrap</artifactId> <version>5.1.3</version> </dependency>","title":"Back to Controller and View"},{"location":"bootcamp/day-1/basic-list/#complete-the-basic-functionality","text":"You have known the overall groundwork required to implement a feature in the TDD approach. The next task is to ensure the user can actually create a new todo item. Now try to work on your own. But do not worry, there will be hints on how to complete it. Your tasks are as follows: Add a new test case in TodoListControllerTest that verifies the correctness of incoming HTTP POST message. Try to figure out how to use MockMvc to simulate an HTTP POST message with a data payload (i.e. the new todo item submitted via an HTML form). Add a new method in TodoListController that handles incoming HTTP POST message containing the new todo item. Use @PostMapping annotation to designate the new method as the handler of an incoming HTTP POST message to /list path. You also need to add a parameter into the method, so you can obtain the new todo item in the HTTP POST message. Try to run the application from time to time. While having test suites that are executed by a test runner is important, do not forget to run the app manually and try using it as an actual user. You can run the app by executing main() method in SitodoApplication class, or by calling mvnw spring-boot:run Maven command. If you have finished, do not forget to save your latest work as a commit and push it to GitHub: git add <path to the changed files> git commit git push","title":"Complete the Basic Functionality"},{"location":"bootcamp/day-1/end-day-1/","text":"End of Day 1 Congratulations! You have reached the end of mandatory tasks for Day 1. Agenda for Day 2 You will continue work on the todo list app. You might have noticed that the current iteration of the app can only contain a single todo list. Tomorrow you will learn how to complete the todo list functionality by implementing the following features: Update and delete a todo list item Automate test execution using GitHub Actions Create a database migration Tomorrow you will learn how to implement a multiple todo lists functionality and begin to refactor the current app to use PostgreSQL database. Additional Material: Functional Test The TDD approach that you learned from today's session is a TDD process that starts from the \"inside\" or the innermost layer of the application. We often call this approach \"inside-out TDD\". We start by developing \"unit test\" that tests each \"unit\" (function, class, method) independently. Afterward, we add tests that verify the integration of units, i.e. \"integration test\". And finally, we create tests that verify the correctness of the features in the application, i.e. \"functional test\". There is another TDD approach called \"outside-in TDD\". As you might have guessed, it started from the outermost layer of the application. We start by developing the functional tests. Since the initial implementation will fail due to the tests, we develop more tests in the lower layer of the application. Afterward, we began to develop the actual implementation to pass the tests. You can create a functional test by using a browser automation tool such as Selenium . To integrate Selenium with JUnit 5 test runner included in Spring Boot, you can use a test framework called Selenide . It provides higher-level abstraction to Selenium and improves the developer experience in setting up functional test. To include Selenide to the project, add the following dependency declaration into pom.xml : <dependency> <groupId>com.codeborne</groupId> <artifactId>selenide</artifactId> <version>6.7.4</version> <scope>test</scope> </dependency> An example of functional test: import org.junit.jupiter.api.DisplayName; import org.junit.jupiter.api.Test; import org.springframework.boot.test.context.SpringBootTest; import org.springframework.boot.test.web.server.LocalServerPort; import org.springframework.beans.factory.annotation.Value; import static org.junit.jupiter.api.Assertions.assertTrue; import static com.codeborne.selenide.Selenide.open; import static com.codeborne.selenide.Selenide.title; import static com.codeborne.selenide.Configuration.baseUrl; import static com.codeborne.selenide.Configuration.browser; import static com.codeborne.selenide.Configuration.headless; import static com.codeborne.selenide.Selenide.$; import static com.codeborne.selenide.Selenide.closeWebDriver; @SpringBootTest(webEnvironment = RANDOM_PORT) @DisplayName(\"Smoke Test\") class SmokeTest { @LocalServerPort protected int serverPort; @Value(\"${sitodo.baseUrl:http://localhost}\") private String testBaseUrl; @Test @DisplayName(\"Verify text in <title> tag\") void site_hasTitle() { browser = \"firefox\"; // Or your favourite browser baseUrl = String.format(\"%s:%d\", testBaseUrl, serverPort); open(\"/\"); assertTrue(title().contains(\"Sitodo\"), \"The browser title was: \" + title()); closeWebDriver(); } } The example above tries to verify if the title displayed on the Web browser contains \"Sitodo\" string. The test runner will open up a Web browser and instruct it to open the Web application at given URL (i.e. / ). The test runner then will query the state of Web browser when performing verification. If you are interested, you can try developing functional tests using Selenium & Selenide. Implement the tests that simulate user (and browser) actions when opening a todo list and submitting a new todo item!","title":"Recap"},{"location":"bootcamp/day-1/end-day-1/#end-of-day-1","text":"Congratulations! You have reached the end of mandatory tasks for Day 1.","title":"End of Day 1"},{"location":"bootcamp/day-1/end-day-1/#agenda-for-day-2","text":"You will continue work on the todo list app. You might have noticed that the current iteration of the app can only contain a single todo list. Tomorrow you will learn how to complete the todo list functionality by implementing the following features: Update and delete a todo list item Automate test execution using GitHub Actions Create a database migration Tomorrow you will learn how to implement a multiple todo lists functionality and begin to refactor the current app to use PostgreSQL database.","title":"Agenda for Day 2"},{"location":"bootcamp/day-1/end-day-1/#additional-material-functional-test","text":"The TDD approach that you learned from today's session is a TDD process that starts from the \"inside\" or the innermost layer of the application. We often call this approach \"inside-out TDD\". We start by developing \"unit test\" that tests each \"unit\" (function, class, method) independently. Afterward, we add tests that verify the integration of units, i.e. \"integration test\". And finally, we create tests that verify the correctness of the features in the application, i.e. \"functional test\". There is another TDD approach called \"outside-in TDD\". As you might have guessed, it started from the outermost layer of the application. We start by developing the functional tests. Since the initial implementation will fail due to the tests, we develop more tests in the lower layer of the application. Afterward, we began to develop the actual implementation to pass the tests. You can create a functional test by using a browser automation tool such as Selenium . To integrate Selenium with JUnit 5 test runner included in Spring Boot, you can use a test framework called Selenide . It provides higher-level abstraction to Selenium and improves the developer experience in setting up functional test. To include Selenide to the project, add the following dependency declaration into pom.xml : <dependency> <groupId>com.codeborne</groupId> <artifactId>selenide</artifactId> <version>6.7.4</version> <scope>test</scope> </dependency> An example of functional test: import org.junit.jupiter.api.DisplayName; import org.junit.jupiter.api.Test; import org.springframework.boot.test.context.SpringBootTest; import org.springframework.boot.test.web.server.LocalServerPort; import org.springframework.beans.factory.annotation.Value; import static org.junit.jupiter.api.Assertions.assertTrue; import static com.codeborne.selenide.Selenide.open; import static com.codeborne.selenide.Selenide.title; import static com.codeborne.selenide.Configuration.baseUrl; import static com.codeborne.selenide.Configuration.browser; import static com.codeborne.selenide.Configuration.headless; import static com.codeborne.selenide.Selenide.$; import static com.codeborne.selenide.Selenide.closeWebDriver; @SpringBootTest(webEnvironment = RANDOM_PORT) @DisplayName(\"Smoke Test\") class SmokeTest { @LocalServerPort protected int serverPort; @Value(\"${sitodo.baseUrl:http://localhost}\") private String testBaseUrl; @Test @DisplayName(\"Verify text in <title> tag\") void site_hasTitle() { browser = \"firefox\"; // Or your favourite browser baseUrl = String.format(\"%s:%d\", testBaseUrl, serverPort); open(\"/\"); assertTrue(title().contains(\"Sitodo\"), \"The browser title was: \" + title()); closeWebDriver(); } } The example above tries to verify if the title displayed on the Web browser contains \"Sitodo\" string. The test runner will open up a Web browser and instruct it to open the Web application at given URL (i.e. / ). The test runner then will query the state of Web browser when performing verification. If you are interested, you can try developing functional tests using Selenium & Selenide. Implement the tests that simulate user (and browser) actions when opening a todo list and submitting a new todo item!","title":"Additional Material: Functional Test"},{"location":"bootcamp/day-1/hello-tdd/","text":"Hello, Test-Driven Development Let us start by creating a controller class named HelloController in src/main/java directory, specifically under the package that was initialised by Spring Initialzr: import org.springframework.web.bind.annotation.GetMapping; @Controller public class HelloController { @GetMapping(\"/hello\") public String showHello() { return \"\"; } } We left the implementation empty for now. This is called as stubbing or creating an empty implementation. If the return value of a method in a controller class is a string, then the framework expects the return value contains the name of a Web page template. Notice there are two directories in src directory: main and test . The main directory contains the actual code for implementing the application. We often call the actual code as the production code . In contrast, the test directory contains the code for testing the application. It is also known as the test code . My First Test Case Create a new class named HelloControllerTest in controller package of the test code. The class will contain one or more instance methods that will execute the test cases. Let us start with a test case that verifies showHello method uses a Web page template named hello . Create a method named showHello_ok in HelloControllerTest : import org.junit.jupiter.api.Test; import static org.junit.jupiter.api.Assertions.*; public class HelloControllerTest { @Test void showHello_ok() { // [Setup] HelloController helloController = new HelloController(); // [Exercise] String result = helloController.showHello(); // [Verify] assertEquals(\"hello\", result); // [Teardown] // Do nothing } } The method that implements a test case can be structured into four sections: Setup , Exercise , Verify , and Teardown sections. Setup is used to initialise the test environment (e.g. the object to be tested, sample data, load test case input). Exercise , as its name implies, executes the procedures that invoke the production code that are being tested. Verify contains procedures that verify the result from the Exercise . Teardown usually contains procedures to clean up the test environment. Run the test suite via the shortcut in the editor or use Maven command mvnw test . If you implement the method exactly as written in this document, the test case execution will fail. That is the way how test-driven development is conducted. We always (or, strive to) start with writing a test case that initially fails. Pass the First Test According to the first test case, it expects the controller to use a Web page template (or often called as \"view\") named hello to generate the HTML response. Therefore, if you want to make the test pass, you need to make an HTML view with the same name. Now, create a new HTML view in templates directory. The content can be empty, since we only want to make the test pass. But at least, write something in the HTML such as a \"Hello, World\" message. At this point, we can verify that the controller works fine as an independent unit. The implementation of showHello returns the correct string value as we expected. However, we still do not know if showHello will behave as intended when it has to handle an actual HTTP request. This is where we are going to test the implementation in a mock/simulated environment. Test in a Mock Environment We know that showHello is an HTTP request handler implemented in a controller. If we want to actually verify if the implementation is correct, we can test the implementation in a simulated Web server. Go back to the test code and update HelloControllerTest class with the following code snippet: // New imports import org.springframework.beans.factory.annotation.Autowired; import org.springframework.test.web.servlet.MockMvc; import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest; import static java.nio.charset.StandardCharsets.UTF_8; import static org.springframework.http.MediaType.TEXT_HTML; import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get; import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*; // New annotation @WebMvcTest(HelloController.class) class HelloControllerTest { // New instance variable @Autowired private MockMvc mockMvc; @Test void showHello_ok() { // Omitted for brevity } @Test void showHello_okResponse() throws Exception { mockMvc.perform(get(\"/hello\")).andExpectAll( status().isOk(), content().contentTypeCompatibleWith(TEXT_HTML), content().encoding(UTF_8), view().name(\"hello\") ); } } The addition of @WebMvcTest annotation will make the test suite to be executed by a test runner provided by Spring framework. It will build and run the production code in a simulated Web server. Hence, it is possible for the test cases to run against a running application. For example, the new test case above will use an instance of MockMvc , which automatically injected by the Spring framework during runtime, to send an HTTP GET request to /hello path in the application. Then, we try to verify the HTTP response given by the application. Try to run the test suite again, either via the shortcut in the IDE or mvnw test command in the shell. You will see that the test suite does not run instantly as they previously did. The test runner now runs the production code on a simulated server before executing the test cases. Once you have verified all test cases pass, save your work as a new Git commit and push it to GitHub: # Track all changes in both production and test codes git add src/test/java git add src/main/java # And commit the changes into a single commit git commit You have gone through a single TDD cycle. It starts with writing a test, followed by the implementation to make the test pass. We have not covered refactoring in a TDD cycle since the production code is still quite simple. In the next section, you will deploy the app to a Platform-as-a-Service provider and learn how to automate the deployment process. You will also see how to ensure that the test suite is always executed whenever you pushed commits to GitHub. Make sure you have created an account on Heroku before continuing to the next section.","title":"Hello, TDD"},{"location":"bootcamp/day-1/hello-tdd/#hello-test-driven-development","text":"Let us start by creating a controller class named HelloController in src/main/java directory, specifically under the package that was initialised by Spring Initialzr: import org.springframework.web.bind.annotation.GetMapping; @Controller public class HelloController { @GetMapping(\"/hello\") public String showHello() { return \"\"; } } We left the implementation empty for now. This is called as stubbing or creating an empty implementation. If the return value of a method in a controller class is a string, then the framework expects the return value contains the name of a Web page template. Notice there are two directories in src directory: main and test . The main directory contains the actual code for implementing the application. We often call the actual code as the production code . In contrast, the test directory contains the code for testing the application. It is also known as the test code .","title":"Hello, Test-Driven Development"},{"location":"bootcamp/day-1/hello-tdd/#my-first-test-case","text":"Create a new class named HelloControllerTest in controller package of the test code. The class will contain one or more instance methods that will execute the test cases. Let us start with a test case that verifies showHello method uses a Web page template named hello . Create a method named showHello_ok in HelloControllerTest : import org.junit.jupiter.api.Test; import static org.junit.jupiter.api.Assertions.*; public class HelloControllerTest { @Test void showHello_ok() { // [Setup] HelloController helloController = new HelloController(); // [Exercise] String result = helloController.showHello(); // [Verify] assertEquals(\"hello\", result); // [Teardown] // Do nothing } } The method that implements a test case can be structured into four sections: Setup , Exercise , Verify , and Teardown sections. Setup is used to initialise the test environment (e.g. the object to be tested, sample data, load test case input). Exercise , as its name implies, executes the procedures that invoke the production code that are being tested. Verify contains procedures that verify the result from the Exercise . Teardown usually contains procedures to clean up the test environment. Run the test suite via the shortcut in the editor or use Maven command mvnw test . If you implement the method exactly as written in this document, the test case execution will fail. That is the way how test-driven development is conducted. We always (or, strive to) start with writing a test case that initially fails.","title":"My First Test Case"},{"location":"bootcamp/day-1/hello-tdd/#pass-the-first-test","text":"According to the first test case, it expects the controller to use a Web page template (or often called as \"view\") named hello to generate the HTML response. Therefore, if you want to make the test pass, you need to make an HTML view with the same name. Now, create a new HTML view in templates directory. The content can be empty, since we only want to make the test pass. But at least, write something in the HTML such as a \"Hello, World\" message. At this point, we can verify that the controller works fine as an independent unit. The implementation of showHello returns the correct string value as we expected. However, we still do not know if showHello will behave as intended when it has to handle an actual HTTP request. This is where we are going to test the implementation in a mock/simulated environment.","title":"Pass the First Test"},{"location":"bootcamp/day-1/hello-tdd/#test-in-a-mock-environment","text":"We know that showHello is an HTTP request handler implemented in a controller. If we want to actually verify if the implementation is correct, we can test the implementation in a simulated Web server. Go back to the test code and update HelloControllerTest class with the following code snippet: // New imports import org.springframework.beans.factory.annotation.Autowired; import org.springframework.test.web.servlet.MockMvc; import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest; import static java.nio.charset.StandardCharsets.UTF_8; import static org.springframework.http.MediaType.TEXT_HTML; import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get; import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*; // New annotation @WebMvcTest(HelloController.class) class HelloControllerTest { // New instance variable @Autowired private MockMvc mockMvc; @Test void showHello_ok() { // Omitted for brevity } @Test void showHello_okResponse() throws Exception { mockMvc.perform(get(\"/hello\")).andExpectAll( status().isOk(), content().contentTypeCompatibleWith(TEXT_HTML), content().encoding(UTF_8), view().name(\"hello\") ); } } The addition of @WebMvcTest annotation will make the test suite to be executed by a test runner provided by Spring framework. It will build and run the production code in a simulated Web server. Hence, it is possible for the test cases to run against a running application. For example, the new test case above will use an instance of MockMvc , which automatically injected by the Spring framework during runtime, to send an HTTP GET request to /hello path in the application. Then, we try to verify the HTTP response given by the application. Try to run the test suite again, either via the shortcut in the IDE or mvnw test command in the shell. You will see that the test suite does not run instantly as they previously did. The test runner now runs the production code on a simulated server before executing the test cases. Once you have verified all test cases pass, save your work as a new Git commit and push it to GitHub: # Track all changes in both production and test codes git add src/test/java git add src/main/java # And commit the changes into a single commit git commit You have gone through a single TDD cycle. It starts with writing a test, followed by the implementation to make the test pass. We have not covered refactoring in a TDD cycle since the production code is still quite simple. In the next section, you will deploy the app to a Platform-as-a-Service provider and learn how to automate the deployment process. You will also see how to ensure that the test suite is always executed whenever you pushed commits to GitHub. Make sure you have created an account on Heroku before continuing to the next section.","title":"Test in a Mock Environment"},{"location":"bootcamp/day-1/init-spring/","text":"Project Initialisation Go to Spring Initializr . Initialise a Spring Boot Project Choose the following options: Maven project Java language Spring Boot version 2.7.4 (the latest stable version at the time of writing) Write the name of the base Java package in the group field. The name should follow the reverse-order domain naming scheme. Usually, the name is based on the actual domain name of a company. For example, if you work on a company called Example and the domain name is example.com , then the reverse-order name is com.example . Write the name of the application in the artifact and name fields. Make sure the name starts with an alphabet symbol and does not contain a hyphen (e.g. - ). Provide a short description of the project in the description field. Package name field should not be modified since it is generated from the values set in group and artifact fields. For example, if the group is set to com.example and artifact is set to sitodo , then the generated name will be com.example.sitodo . Choose Java version 17 because it is the LTS (long-term support) version at the time of writing. Include the following dependencies as well: Lombok Spring Web Thymeleaf Spring Data JPA H2 Database The final options should be similar to the following screenshot: Generate and download the base code as a ZIP file by clicking the Generate button. Extract the downloaded ZIP file into a directory of your choice. For example, if you extract the ZIP file into the home directory of your operating system (OS), there would be a new directory containing the source code at the following path: GNU/Linux-based OS (e.g. Debian, Ubuntu): /home/MyAccount/sitodo Windows: C:\\Users\\MyAccount\\sitodo Open a (terminal) shell in your OS and go to the project directory: cd <path to the project directory> Use provided Maven wrapper ( mvnw ) in the project directory to build the project using package command: ./mvnw package If everything goes well, you will see a new directory named output that contains a JAR file. Since we have verified that the project can be built successfully, clean up the build artifacts using mvnw clean command: ./mvnw clean Initialise a Local Git Repository Initialise the current working directory where the project was extracted as a new Git repository: git init -b main . Configure the local repository to use your credentials on GitHub: git config user.name \"<Full Name>\" git config user.email \"<Email Address>\" Add all files into Git and save it as a new commit: git add . git commit Create an Online Git Repository on GitHub Go to GitHub and create a new repository. You can name it anything, but try to make it descriptive. For the purpose of the bootcamp, you can name your new repository as \"Sitodo\". Once you created the new repository, take note of its clone URL on GitHub. Pick the HTTPS clone URL if you are new to Git and GitHub. Then, go back to your shell and add a new remote called origin using git command: git remote add origin <URL to the remote repository> Then push the commit from the main branch (i.e. the default branch in your local Git repository) to GitHub: git push origin main Open GitHub page of your repository and see if the source code has been pushed successfully. Now let us move on to the next part of the course, which is to get introduced with test-driven development.","title":"Initialise Project"},{"location":"bootcamp/day-1/init-spring/#project-initialisation","text":"Go to Spring Initializr .","title":"Project Initialisation"},{"location":"bootcamp/day-1/init-spring/#initialise-a-spring-boot-project","text":"Choose the following options: Maven project Java language Spring Boot version 2.7.4 (the latest stable version at the time of writing) Write the name of the base Java package in the group field. The name should follow the reverse-order domain naming scheme. Usually, the name is based on the actual domain name of a company. For example, if you work on a company called Example and the domain name is example.com , then the reverse-order name is com.example . Write the name of the application in the artifact and name fields. Make sure the name starts with an alphabet symbol and does not contain a hyphen (e.g. - ). Provide a short description of the project in the description field. Package name field should not be modified since it is generated from the values set in group and artifact fields. For example, if the group is set to com.example and artifact is set to sitodo , then the generated name will be com.example.sitodo . Choose Java version 17 because it is the LTS (long-term support) version at the time of writing. Include the following dependencies as well: Lombok Spring Web Thymeleaf Spring Data JPA H2 Database The final options should be similar to the following screenshot: Generate and download the base code as a ZIP file by clicking the Generate button. Extract the downloaded ZIP file into a directory of your choice. For example, if you extract the ZIP file into the home directory of your operating system (OS), there would be a new directory containing the source code at the following path: GNU/Linux-based OS (e.g. Debian, Ubuntu): /home/MyAccount/sitodo Windows: C:\\Users\\MyAccount\\sitodo Open a (terminal) shell in your OS and go to the project directory: cd <path to the project directory> Use provided Maven wrapper ( mvnw ) in the project directory to build the project using package command: ./mvnw package If everything goes well, you will see a new directory named output that contains a JAR file. Since we have verified that the project can be built successfully, clean up the build artifacts using mvnw clean command: ./mvnw clean","title":"Initialise a Spring Boot Project"},{"location":"bootcamp/day-1/init-spring/#initialise-a-local-git-repository","text":"Initialise the current working directory where the project was extracted as a new Git repository: git init -b main . Configure the local repository to use your credentials on GitHub: git config user.name \"<Full Name>\" git config user.email \"<Email Address>\" Add all files into Git and save it as a new commit: git add . git commit","title":"Initialise a Local Git Repository"},{"location":"bootcamp/day-1/init-spring/#create-an-online-git-repository-on-github","text":"Go to GitHub and create a new repository. You can name it anything, but try to make it descriptive. For the purpose of the bootcamp, you can name your new repository as \"Sitodo\". Once you created the new repository, take note of its clone URL on GitHub. Pick the HTTPS clone URL if you are new to Git and GitHub. Then, go back to your shell and add a new remote called origin using git command: git remote add origin <URL to the remote repository> Then push the commit from the main branch (i.e. the default branch in your local Git repository) to GitHub: git push origin main Open GitHub page of your repository and see if the source code has been pushed successfully. Now let us move on to the next part of the course, which is to get introduced with test-driven development.","title":"Create an Online Git Repository on GitHub"},{"location":"bootcamp/day-1/qa-automation/","text":"Quality Assurance & Automation In order to make the production code can be built and deployed on Heroku, we have to follow the rules dictated by the service provider (i.e. Heroku). Create a new file called Procfile in the root project directory. It defines one or more processes that can run on Heroku's environment. For our purpose today, you only need to define a single process called web that runs the application. The content can be seen in the following snippet: web: java -Dserver.port=$PORT $JAVA_OPTS -jar target/*.jar You also need to create a new file named system.properties in the root project directory. It will be used to bind a specific version of Java to the deployment environment. The content can be seen in the following snippet: java.runtime.version=17 Add new files into local Git history and push the commit to GitHub: git add Procfile system.properties git commit git push origin main Setting Up GitHub Actions Create a new file with name dpl.yml in .github/workflows folder in your root project directory. This file is used to execute deployment by runner from GitHub Actions. The content of the dpl.yml is as follows: --- name: Deploy on: push: branches: - main jobs: deploy: runs-on: ubuntu-22.04 env: HEROKU_API_KEY: ${{ secrets.HEROKU_API_KEY }} HEROKU_APP_NAME: ${{ secrets.HEROKU_APP_NAME }} steps: - name: Checkout repository uses: actions/checkout@v3 - name: Set up Ruby uses: ruby/setup-ruby@v1 with: ruby-version: \"2.7\" - name: Install dpl run: gem install dpl - name: Deploy to Heroku run: dpl --provider=heroku --app=$HEROKU_APP_NAME --api-key=$HEROKU_API_KEY - uses: chrnorm/deployment-action@releases/v1 name: Create GitHub deployment with: initial_status: success token: ${{ github.token }} target_url: https://${{ secrets.HEROKU_APP_NAME }}.herokuapp.com environment: production After you perform all the procedures above, your new Spring Boot application is ready to deploy in Heroku. If you open the GitHub Actions tab in your repository, it seems that a workflow is already running, but the status is failed because there is an error that says there are some parameters in deployment job that were not found. This thing happened because you have not configured the parameters needed by the workflow . Now, you will configure those parameters: Create a Heroku account if you have not done so. You can create a Heroku account on its login page on this link . Once you have logged in to the dashboard page, create a Heroku app and take note of the name. Copy API Key from your account. API Key can be found in Account Settings -> API Key . Keep your API Key and the information about your Heroku application in a text file with given format: HEROKU_API_KEY: <YOUR_API_KEY_VALUE> HEROKU_APP_NAME: <YOUR_HEROKU_APPLICATION_NAME> Open your GitHub repository configuration and open the Secrets section for GitHub Actions ( Settings -> Secrets -> Actions ). Add a new repository secret variable to do the deployment . Key-Value pair from the variable that you\u2019ll make can be obtained from the information that you noted in the previous text file. Example can be seen below: (NAME)HEROKU_APP_NAME (VALUE)MY-APPLICATION Keep the notes above somewhere outside the repository. Do not commit your note file into Git, since it contains your Heroku key! Open GitHub Actions and re-run the failed workflow . After you re-run workflow and deployment status become success (can be seen from the green checklist symbol on your repository), you can access the application in https://<heroku-application-name>.herokuapp.com .","title":"Deployment Automation"},{"location":"bootcamp/day-1/qa-automation/#quality-assurance-automation","text":"In order to make the production code can be built and deployed on Heroku, we have to follow the rules dictated by the service provider (i.e. Heroku). Create a new file called Procfile in the root project directory. It defines one or more processes that can run on Heroku's environment. For our purpose today, you only need to define a single process called web that runs the application. The content can be seen in the following snippet: web: java -Dserver.port=$PORT $JAVA_OPTS -jar target/*.jar You also need to create a new file named system.properties in the root project directory. It will be used to bind a specific version of Java to the deployment environment. The content can be seen in the following snippet: java.runtime.version=17 Add new files into local Git history and push the commit to GitHub: git add Procfile system.properties git commit git push origin main","title":"Quality Assurance &amp; Automation"},{"location":"bootcamp/day-1/qa-automation/#setting-up-github-actions","text":"Create a new file with name dpl.yml in .github/workflows folder in your root project directory. This file is used to execute deployment by runner from GitHub Actions. The content of the dpl.yml is as follows: --- name: Deploy on: push: branches: - main jobs: deploy: runs-on: ubuntu-22.04 env: HEROKU_API_KEY: ${{ secrets.HEROKU_API_KEY }} HEROKU_APP_NAME: ${{ secrets.HEROKU_APP_NAME }} steps: - name: Checkout repository uses: actions/checkout@v3 - name: Set up Ruby uses: ruby/setup-ruby@v1 with: ruby-version: \"2.7\" - name: Install dpl run: gem install dpl - name: Deploy to Heroku run: dpl --provider=heroku --app=$HEROKU_APP_NAME --api-key=$HEROKU_API_KEY - uses: chrnorm/deployment-action@releases/v1 name: Create GitHub deployment with: initial_status: success token: ${{ github.token }} target_url: https://${{ secrets.HEROKU_APP_NAME }}.herokuapp.com environment: production After you perform all the procedures above, your new Spring Boot application is ready to deploy in Heroku. If you open the GitHub Actions tab in your repository, it seems that a workflow is already running, but the status is failed because there is an error that says there are some parameters in deployment job that were not found. This thing happened because you have not configured the parameters needed by the workflow . Now, you will configure those parameters: Create a Heroku account if you have not done so. You can create a Heroku account on its login page on this link . Once you have logged in to the dashboard page, create a Heroku app and take note of the name. Copy API Key from your account. API Key can be found in Account Settings -> API Key . Keep your API Key and the information about your Heroku application in a text file with given format: HEROKU_API_KEY: <YOUR_API_KEY_VALUE> HEROKU_APP_NAME: <YOUR_HEROKU_APPLICATION_NAME> Open your GitHub repository configuration and open the Secrets section for GitHub Actions ( Settings -> Secrets -> Actions ). Add a new repository secret variable to do the deployment . Key-Value pair from the variable that you\u2019ll make can be obtained from the information that you noted in the previous text file. Example can be seen below: (NAME)HEROKU_APP_NAME (VALUE)MY-APPLICATION Keep the notes above somewhere outside the repository. Do not commit your note file into Git, since it contains your Heroku key! Open GitHub Actions and re-run the failed workflow . After you re-run workflow and deployment status become success (can be seen from the green checklist symbol on your repository), you can access the application in https://<heroku-application-name>.herokuapp.com .","title":"Setting Up GitHub Actions"},{"location":"bootcamp/day-2/","text":"Bootcamp (Day 2) Still in development. Stay tune!","title":"Bootcamp (Day 2)"},{"location":"bootcamp/day-2/#bootcamp-day-2","text":"Still in development. Stay tune!","title":"Bootcamp (Day 2)"},{"location":"bootcamp/day-2/database-migration/","text":"Database Migration Each time you run the app locally, a new test database is created in-memory. The database only lives when the program is running. When you shut down the app, the database is cleared from the memory as well. While this makes it easy during tutorial, a real software deployment usually uses an actual database that persists the data in a storage medium. A Web application is usually connected to a database engine such as MySQL or PostgreSQL on the production environment. Obviously, we cannot always re-instantiate the database each time we perform deployment. There might be some actual customer data present in the database. Thus, it might cause grief, both for your company and the customer, if the data were deleted after your application re-created the database from scratch on the production environment. To help solve this problem, some frameworks support database migration tool. We can define a series of migration scripts to keep the database updated with the latest changes in the code. For example, we can ensure the table schema on the database is kept synchronized with the data models written in Java. If there is a change in the data model, the migration scripts can define operations to update the database schema. In addition, the migration scripts can also be used to populate the database with static data (such as a default admin user, reference entries, etc.). Spring Boot provides support to two database migration tools: Liquibase and Flyway . In this tutorial, we will use Liquibase. First, create a new directory named db in resources directory of your production code. Then, create another directory named changelog inside the new db directory: # (Mac OS/Linux/bash) the shell command equivalent to the instruction above mkdir -p ./src/main/resources/db/changelog Add a new YAML file named db.changelog-master.yaml in changelog directory: Note: Make sure you named the file correctly! By default, Spring Boot expects a Liquibase master migration script named db.changelog-master.yaml . --- databaseChangeLog: - changeSet: id: 1 author: sitodo_maintainer changes: - createSequence: sequenceName: hibernate_sequence dataType: INTEGER incrementBy: 1 startValue: 1 minValue: 1 - createTable: tableName: todo_item columns: - column: name: id # Approximate the appropriate data type using existing types # from java.sql package: https://docs.oracle.com/en/java/javase/17/docs/api/java.sql/java/sql/Types.html type: INTEGER autoIncrement: true valueSequenceNext: hibernate_sequence constraints: primaryKey: true primaryKeyName: pk_todo_item - column: name: title type: VARCHAR constraints: nullable: false - column: name: finished type: BOOLEAN defaultValueBoolean: false - createTable: tableName: todo_list columns: - column: name: id type: INTEGER autoIncrement: true valueSequenceNext: hibernate_sequence constraints: primaryKey: true primaryKeyName: pk_todo_list - createTable: tableName: todo_list_items columns: - column: name: todo_list_id type: INTEGER constraints: foreignKeyName: fk_todo_list_items_todo_list referencedTableName: todo_list referencedColumnNames: id - column: name: items_id type: INTEGER constraints: foreignKeyName: fk_todo_list_items_todo_item referencedTableName: todo_item referencedColumnNames: id rollback: - dropTable: tableName: todo_list_items - dropTable: tableName: todo_list - dropTable: tableName: todo_item Some database migration tools label their tools as database version control. You can think Liquibase migration scripts similar to Git commits. Each script may contain one or more changeset that will perform database-related operations. For example, the migration script above will do the following: Create a sequence in the database to keep track the auto-generated ID Create every table defined in model package Create a join table to handle one-to-many relationships between TodoList and TodoItem The migration script also contains a rollback procedure that can be executed if you choose to do so via Maven command or Liquibase's CLI tool.","title":"Database Migration"},{"location":"bootcamp/day-2/database-migration/#database-migration","text":"Each time you run the app locally, a new test database is created in-memory. The database only lives when the program is running. When you shut down the app, the database is cleared from the memory as well. While this makes it easy during tutorial, a real software deployment usually uses an actual database that persists the data in a storage medium. A Web application is usually connected to a database engine such as MySQL or PostgreSQL on the production environment. Obviously, we cannot always re-instantiate the database each time we perform deployment. There might be some actual customer data present in the database. Thus, it might cause grief, both for your company and the customer, if the data were deleted after your application re-created the database from scratch on the production environment. To help solve this problem, some frameworks support database migration tool. We can define a series of migration scripts to keep the database updated with the latest changes in the code. For example, we can ensure the table schema on the database is kept synchronized with the data models written in Java. If there is a change in the data model, the migration scripts can define operations to update the database schema. In addition, the migration scripts can also be used to populate the database with static data (such as a default admin user, reference entries, etc.). Spring Boot provides support to two database migration tools: Liquibase and Flyway . In this tutorial, we will use Liquibase. First, create a new directory named db in resources directory of your production code. Then, create another directory named changelog inside the new db directory: # (Mac OS/Linux/bash) the shell command equivalent to the instruction above mkdir -p ./src/main/resources/db/changelog Add a new YAML file named db.changelog-master.yaml in changelog directory: Note: Make sure you named the file correctly! By default, Spring Boot expects a Liquibase master migration script named db.changelog-master.yaml . --- databaseChangeLog: - changeSet: id: 1 author: sitodo_maintainer changes: - createSequence: sequenceName: hibernate_sequence dataType: INTEGER incrementBy: 1 startValue: 1 minValue: 1 - createTable: tableName: todo_item columns: - column: name: id # Approximate the appropriate data type using existing types # from java.sql package: https://docs.oracle.com/en/java/javase/17/docs/api/java.sql/java/sql/Types.html type: INTEGER autoIncrement: true valueSequenceNext: hibernate_sequence constraints: primaryKey: true primaryKeyName: pk_todo_item - column: name: title type: VARCHAR constraints: nullable: false - column: name: finished type: BOOLEAN defaultValueBoolean: false - createTable: tableName: todo_list columns: - column: name: id type: INTEGER autoIncrement: true valueSequenceNext: hibernate_sequence constraints: primaryKey: true primaryKeyName: pk_todo_list - createTable: tableName: todo_list_items columns: - column: name: todo_list_id type: INTEGER constraints: foreignKeyName: fk_todo_list_items_todo_list referencedTableName: todo_list referencedColumnNames: id - column: name: items_id type: INTEGER constraints: foreignKeyName: fk_todo_list_items_todo_item referencedTableName: todo_item referencedColumnNames: id rollback: - dropTable: tableName: todo_list_items - dropTable: tableName: todo_list - dropTable: tableName: todo_item Some database migration tools label their tools as database version control. You can think Liquibase migration scripts similar to Git commits. Each script may contain one or more changeset that will perform database-related operations. For example, the migration script above will do the following: Create a sequence in the database to keep track the auto-generated ID Create every table defined in model package Create a join table to handle one-to-many relationships between TodoList and TodoItem The migration script also contains a rollback procedure that can be executed if you choose to do so via Maven command or Liquibase's CLI tool.","title":"Database Migration"},{"location":"bootcamp/day-2/test-automation/","text":"Test Automation using GitHub Actions Create a new YML file called ci.yml in .github/workflows directory of your project. The file contains a new workflow that shall be executed on every commit that pushed to the repository and on every pull request (PR) created on GitHub. The content of ci.yml is as follows: --- name: Continuous Integration (CI) on: [ push, pull_request ] jobs: test: name: Run all tests runs-on: ubuntu-22.04 env: # Based on the Maven CI/CD template from GitLab: # https://gitlab.com/gitlab-org/gitlab/-/blob/master/lib/gitlab/ci/templates/Maven.gitlab-ci.yml # It is recommended to use these variables to reduce noise in the logs MAVEN_OPTS: > -Dhttps.protocols=TLSv1.2 -Dorg.slf4j.simpleLogger.log.org.apache.maven.cli.transfer.Slf4jMavenTransferListener=WARN -Dorg.slf4j.simpleLogger.showDateTime=true -Djava.awt.headless=true MAVEN_CLI_OPTS: > --batch-mode --errors --fail-at-end --show-version -DinstallAtEnd=true -DdeployAtEnd=true steps: - name: Checkout repository uses: actions/checkout@v3 - name: Set up Java uses: actions/setup-java@v3 with: distribution: \"temurin\" java-version: \"17\" cache: \"maven\" - name: Run unit tests run: mvn $MAVEN_CLI_OPTS test Save the file as a new Git commit and push it to GitHub: git add .github/workflows/ci.yml git commit git push origin main Open the Actions tab on your GitHub repository page. You will see two workflows running in parallel: deploy and ci . Wait for a moment until both workflows finishes. Ensure that both workflows end successfully. It is possible for ci workflow to fail. If the test cases execution contains a failing test result, then ci workflow will report that as a failure in workflow execution. If that is the case with your current code, try to fix your code to make the ci pass. But do not spuriously fix it by rapidly pushing new commit only to see if the ci works. Run the test cases locally using IDE or Maven mvnw test before pushing the latest changes to GitHub. Measure Code/Line Coverage We can measure how extensive a production code is tested by measuring the line coverage. It is a metric that expresses the ratio of tested code compared to all lines on code (LOC). Suppose you have a source code of an application that contains 1000 LOC. If the line coverage reported 75% coverage, it means only 750 out of 1000 LOC that have been executed during testing. The remaining 250 LOC are not yet executed. Based on that fact, you can estimate that 250 LOC are not yet tested (or, \"covered\") by the test cases. If you are using IntelliJ, you can execute tests with coverage via the shortcuts. You can selectively run a test case or a test suite by opening it in the editor, click the green \"Play\" button to show the possible shortcuts and choose \"Run 'Test' with Coverage\", as depicted in the following screenshot: After the test finished, you can see the coverage report in IDE: In this exercise, you will configure Maven to use a plugin called JaCoCo to generate the code coverage report. First, add a new plugin called jacoco-maven-plugin into pom.xml , specifically in the <build> section: <build> <plugins> <plugin> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-maven-plugin</artifactId> <configuration> <excludes> <exclude> <groupId>org.projectlombok</groupId> <artifactId>lombok</artifactId> </exclude> </excludes> </configuration> </plugin> <plugin> <groupId>org.jacoco</groupId> <artifactId>jacoco-maven-plugin</artifactId> <version>0.8.8</version> </plugin> </plugins> </build> Configure the plugin according to an example modified from Baeldung : <plugin> <groupId>org.jacoco</groupId> <artifactId>jacoco-maven-plugin</artifactId> <version>0.8.8</version> <executions> <execution> <id>jacoco-initialize</id> <goals> <goal>prepare-agent</goal> </goals> </execution> <execution> <id>jacoco-site</id> <phase>test</phase> <goals> <goal>report</goal> </goals> </execution> </executions> </plugin> Run the test cases using mvnw test Maven command. The code coverage will be measured during testing. At the end of testing, JaCoco will generate a code coverage report. You can find the report in build directory. The report, by default, is written in HTML, so you can view it in your browser. Status Badges If you check some open-source projects on GitHub, you might have seen some repositories displayed badges in their README. By looking at the badges, you can quickly know some status from the project. You can also do the same with your projects. Some badges are pretty straightforward to set up. For example, you can create a badge that displays the status of a workflow in GitHub Actions. Suppose you want to show the deployment status of your project. Open Actions page on your GitHub repository and click \"Deploy\" workflow. Click \"...\" button at the end of the filter input field on the page and choose \"Create status badge\": Choose default options for branch and event. Then, copy the generated status badge Markdown and put it into your project's README.md file. Save your README.md file as a commit and push it to GitHub. You will see that if you open your project page on GitHub, the README will display the badge. Coverage Badge There are also some badges that require some configuration, such as badges to display a code coverage report. You can use jacoco-badge-generator as a GitHub action in your ci.yml workflow. The project already provided an example in their README file, so read the documentation and try to use it in your own project!","title":"Test Automation"},{"location":"bootcamp/day-2/test-automation/#test-automation-using-github-actions","text":"Create a new YML file called ci.yml in .github/workflows directory of your project. The file contains a new workflow that shall be executed on every commit that pushed to the repository and on every pull request (PR) created on GitHub. The content of ci.yml is as follows: --- name: Continuous Integration (CI) on: [ push, pull_request ] jobs: test: name: Run all tests runs-on: ubuntu-22.04 env: # Based on the Maven CI/CD template from GitLab: # https://gitlab.com/gitlab-org/gitlab/-/blob/master/lib/gitlab/ci/templates/Maven.gitlab-ci.yml # It is recommended to use these variables to reduce noise in the logs MAVEN_OPTS: > -Dhttps.protocols=TLSv1.2 -Dorg.slf4j.simpleLogger.log.org.apache.maven.cli.transfer.Slf4jMavenTransferListener=WARN -Dorg.slf4j.simpleLogger.showDateTime=true -Djava.awt.headless=true MAVEN_CLI_OPTS: > --batch-mode --errors --fail-at-end --show-version -DinstallAtEnd=true -DdeployAtEnd=true steps: - name: Checkout repository uses: actions/checkout@v3 - name: Set up Java uses: actions/setup-java@v3 with: distribution: \"temurin\" java-version: \"17\" cache: \"maven\" - name: Run unit tests run: mvn $MAVEN_CLI_OPTS test Save the file as a new Git commit and push it to GitHub: git add .github/workflows/ci.yml git commit git push origin main Open the Actions tab on your GitHub repository page. You will see two workflows running in parallel: deploy and ci . Wait for a moment until both workflows finishes. Ensure that both workflows end successfully. It is possible for ci workflow to fail. If the test cases execution contains a failing test result, then ci workflow will report that as a failure in workflow execution. If that is the case with your current code, try to fix your code to make the ci pass. But do not spuriously fix it by rapidly pushing new commit only to see if the ci works. Run the test cases locally using IDE or Maven mvnw test before pushing the latest changes to GitHub.","title":"Test Automation using GitHub Actions"},{"location":"bootcamp/day-2/test-automation/#measure-codeline-coverage","text":"We can measure how extensive a production code is tested by measuring the line coverage. It is a metric that expresses the ratio of tested code compared to all lines on code (LOC). Suppose you have a source code of an application that contains 1000 LOC. If the line coverage reported 75% coverage, it means only 750 out of 1000 LOC that have been executed during testing. The remaining 250 LOC are not yet executed. Based on that fact, you can estimate that 250 LOC are not yet tested (or, \"covered\") by the test cases. If you are using IntelliJ, you can execute tests with coverage via the shortcuts. You can selectively run a test case or a test suite by opening it in the editor, click the green \"Play\" button to show the possible shortcuts and choose \"Run 'Test' with Coverage\", as depicted in the following screenshot: After the test finished, you can see the coverage report in IDE: In this exercise, you will configure Maven to use a plugin called JaCoCo to generate the code coverage report. First, add a new plugin called jacoco-maven-plugin into pom.xml , specifically in the <build> section: <build> <plugins> <plugin> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-maven-plugin</artifactId> <configuration> <excludes> <exclude> <groupId>org.projectlombok</groupId> <artifactId>lombok</artifactId> </exclude> </excludes> </configuration> </plugin> <plugin> <groupId>org.jacoco</groupId> <artifactId>jacoco-maven-plugin</artifactId> <version>0.8.8</version> </plugin> </plugins> </build> Configure the plugin according to an example modified from Baeldung : <plugin> <groupId>org.jacoco</groupId> <artifactId>jacoco-maven-plugin</artifactId> <version>0.8.8</version> <executions> <execution> <id>jacoco-initialize</id> <goals> <goal>prepare-agent</goal> </goals> </execution> <execution> <id>jacoco-site</id> <phase>test</phase> <goals> <goal>report</goal> </goals> </execution> </executions> </plugin> Run the test cases using mvnw test Maven command. The code coverage will be measured during testing. At the end of testing, JaCoco will generate a code coverage report. You can find the report in build directory. The report, by default, is written in HTML, so you can view it in your browser.","title":"Measure Code/Line Coverage"},{"location":"bootcamp/day-2/test-automation/#status-badges","text":"If you check some open-source projects on GitHub, you might have seen some repositories displayed badges in their README. By looking at the badges, you can quickly know some status from the project. You can also do the same with your projects. Some badges are pretty straightforward to set up. For example, you can create a badge that displays the status of a workflow in GitHub Actions. Suppose you want to show the deployment status of your project. Open Actions page on your GitHub repository and click \"Deploy\" workflow. Click \"...\" button at the end of the filter input field on the page and choose \"Create status badge\": Choose default options for branch and event. Then, copy the generated status badge Markdown and put it into your project's README.md file. Save your README.md file as a commit and push it to GitHub. You will see that if you open your project page on GitHub, the README will display the badge.","title":"Status Badges"},{"location":"bootcamp/day-2/test-automation/#coverage-badge","text":"There are also some badges that require some configuration, such as badges to display a code coverage report. You can use jacoco-badge-generator as a GitHub action in your ci.yml workflow. The project already provided an example in their README file, so read the documentation and try to use it in your own project!","title":"Coverage Badge"},{"location":"bootcamp/day-2/update-data-model/","text":"One of Many Lists Today you will update the application by making the user able to create multiple lists each time they open the app. At the same time, you will practice a Git workflow called Feature Branch workflow. First, make sure your local Git repository has the same history as the remote Git repository on GitHub. If you have any Git commits that have not been pushed to GitHub, please commit them now. Similarly, if you made changes on GitHub, ensure the Git commit history is pulled into your local Git repository. # Push commits git push origin main # Pull commits from remote Git repository into the currently active branch git pull origin main According to Feature Branch workflow, any new changes to the codebase should be done in a separate branch from the main branch. Once the changes have been tested, the branch is merged into the main branch. This is to ensure any ongoing development will not break the application that built from the main branch. Data Persistence Layer Let us start from the data persistence layer. Open a shell (or terminal in the IDE) and create a new branch named todo-list-v2 using git branch and git checkout commands: git branch todo-list-v2 git checkout todo-list-v2 # Or shorter form: git checkout -b todo-list-v2 Open model package in the production code and update TodoItem class with following code snippets: // TodoItem.java import lombok.Data; import lombok.NoArgsConstructor; import javax.persistence.*; @Data @Entity @NoArgsConstructor public class TodoItem { @Id @GeneratedValue(strategy = GenerationType.SEQUENCE) private Long id; @Column(nullable = false) private String title; @Column private Boolean finished = Boolean.FALSE; public TodoItem(String title) { this.title = title; } public TodoItem(Long id, String title) { this.id = id; this.title = title; } } Then, add a new model class named TodoList in the same model package as TodoItem class: import lombok.Data; import lombok.NoArgsConstructor; import javax.persistence.*; import java.util.List; @Data @Entity @NoArgsConstructor public class TodoList { @Id @GeneratedValue(strategy = GenerationType.SEQUENCE) private Long id; @OneToMany(cascade = {CascadeType.PERSIST, CascadeType.MERGE}) private List<TodoItem> items; public TodoList(List<TodoItem> items) { this.items= items; } public void addTodoItem(TodoItem item) { items.add(item); } } Based on the new data model, all instances of TodoItem will be associated to a TodoList . Or in other words, a TodoList will have one-to-many relationship to TodoItem . Certainly, this will require you to update the code across every layer. Repository Layer Open repository package in the production code and update TodoListRepository class with following code snippets: import org.springframework.data.repository.CrudRepository; import org.springframework.stereotype.Repository; @Repository public interface TodoListRepository extends CrudRepository<TodoList, Long> { } Based on the change above, TodoItem was replaced with TodoList . All queries for querying todo items will use the one-to-many relationship mapping possessed by TodoList . Service Layer Open service package in the production code and update TodoListService class with following code snippets: import com.example.sitodo.model.TodoItem; import com.example.sitodo.model.TodoList; import com.example.sitodo.repository.TodoListRepository; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.beans.factory.annotation.Value; import org.springframework.stereotype.Service; import java.util.List; import java.util.NoSuchElementException; import java.util.Optional; @Service public class TodoListService { private static final Logger LOG = LoggerFactory.getLogger(TodoListService.class); private static final String TODO_LIST_DOES_NOT_EXIST_FMT = \"TodoList(id=%d) does not exist\"; private TodoListRepository todoListRepository; @Autowired public void setTodoListRepository(TodoListRepository todoListRepository) { this.todoListRepository = todoListRepository; } public TodoList getTodoListById(Long id) throws NoSuchElementException { Optional<TodoList> result = todoListRepository.findById(id); return result.get(); } public TodoList addTodoItem(TodoItem todoItem) { TodoList list = new TodoList(List.of(todoItem)); return todoListRepository.save(list); } public TodoList addTodoItem(Long id, TodoItem todoItem) throws NoSuchElementException { Optional<TodoList> result = todoListRepository.findById(id); TodoList foundList = result.get(); foundList.addTodoItem(todoItem); return todoListRepository.save(foundList); } public TodoList updateTodoItem(Long listId, Long itemId, Boolean status) throws NoSuchElementException { Optional<TodoList> result = todoListRepository.findById(listId); // TODO: Implement me! return null; } public Boolean deleteTodoItem(Long listId, Long itemId) throws NoSuchElementException { Optional<TodoList> result = todoListRepository.findById(listId); // TODO: Implement me! return Boolean.FALSE; } } Update the test cases for TodoListService in the test code: // TodoListServiceTest.java import org.junit.jupiter.api.DisplayName; import org.junit.jupiter.api.Tag; import org.junit.jupiter.api.Test; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.beans.factory.annotation.Value; import org.springframework.boot.test.context.SpringBootTest; import org.springframework.boot.test.mock.mockito.MockBean; import java.util.*; import java.util.stream.IntStream; import static org.hamcrest.MatcherAssert.assertThat; import static org.hamcrest.Matchers.*; import static org.junit.jupiter.api.Assertions.*; import static org.mockito.ArgumentMatchers.any; import static org.mockito.ArgumentMatchers.anyLong; import static org.mockito.Mockito.mock; import static org.mockito.Mockito.when; @SpringBootTest class TodoListServiceTest { @Autowired private TodoListService todoListService; @MockBean private TodoListRepository todoListRepository; @Test @DisplayName(\"Given an existing ID, getTodoListById should return an existing list\") void getTodoListById_ok() { TodoList todoList = createTodoList(\"Buy milk\"); when(todoListRepository.findById(anyLong())).thenReturn(Optional.of(todoList)); TodoList savedList = todoListService.getTodoListById(1L); assertFalse(savedList.getItems().isEmpty()); } @Test @DisplayName(\"Suppose the list does not exist, getTodoListById should throw an exception\") void getTodoListById_exception() { when(todoListRepository.findById(anyLong())).thenReturn(Optional.empty()); assertThrows(NoSuchElementException.class, () -> todoListService.getTodoListById(1L)); } @Test @DisplayName(\"Given a new todo item, addTodoItem should save the item into a new list\") void addTodoItem_ok() { TodoItem todoItem = new TodoItem(\"Buy milk\"); when(todoListRepository.save(any(TodoList.class))).thenReturn(new TodoList(List.of(todoItem))); TodoList savedList = todoListService.addTodoItem(todoItem); TodoItem savedTodoItem = savedList.getItems().get(0); assertFalse(savedList.getItems().isEmpty()); assertEquals(\"Buy milk\", savedTodoItem.getTitle()); } @Test @DisplayName(\"Given a todo item, addTodoItem should save the item into an existing list\") void addTodoItem_existingList_ok() { TodoList list = createTodoList(\"Buy milk\"); when(todoListRepository.findById(anyLong())).thenReturn(Optional.of(list)); todoListService.addTodoItem(1L, new TodoItem(\"Touch grass\")); assertEquals(2, list.getItems().size(), \"The numbers of items in the list: \" + list.getItems().size()); } @Test @DisplayName(\"Suppose the list does not exist, addTodoItem should throw an exception\") void addTodoItem_existingList_exception() { when(todoListRepository.findById(anyLong())).thenReturn(Optional.empty()); assertThrows(NoSuchElementException.class, () -> todoListService.addTodoItem(1L, new TodoItem(\"Buy milk\"))); } @Test @DisplayName(\"Given an existing list with an item, updateTodoItem should update the status of an item\") void updateTodoItem_ok() { // TODO: Implement me! } @Test @DisplayName(\"Suppose the list does not exist, updateTodoItem should throw an exception\") void updateTodoItem_exception() { when(todoListRepository.findById(anyLong())).thenReturn(Optional.empty()); assertThrows(NoSuchElementException.class, () -> todoListService.updateTodoItem(1L, 2L, true)); } // TODO: Create tests for deleteTodoItem private TodoList createTodoList(String... items) { TodoList list = new TodoList(new ArrayList<>()); Arrays.stream(items) .map(TodoItem::new) .forEach(list::addTodoItem); return list; } } Notice that there are several methods and TODO comments that need to be resolved. Controller Open controller package in the production code and update TodoListController class with following code snippets: // TodoListController.java import com.example.sitodo.model.TodoItem; import com.example.sitodo.model.TodoList; import com.example.sitodo.service.TodoListService; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Controller; import org.springframework.ui.Model; import org.springframework.web.bind.annotation.*; import java.util.NoSuchElementException; @Controller public class TodoListController { private static final Logger LOG = LoggerFactory.getLogger(TodoListController.class); private TodoListService todoListService; @Autowired public void setTodoListService(TodoListService todoListService) { this.todoListService = todoListService; } @GetMapping(\"/list\") public String showList(TodoList todoList, Model model) { model.addAttribute(\"todoList\", todoList); return \"list\"; } @GetMapping(\"/list/{id}\") public String showList(@PathVariable(\"id\") Long id, Model model) { TodoList foundTodoList = todoListService.getTodoListById(id); model.addAttribute(\"todoList\", foundTodoList); return \"list\"; } @PostMapping(\"/list\") public String newItem(@RequestParam(\"item_text\") String item) { TodoList saved = todoListService.addTodoItem(new TodoItem(item)); return redirectToList(saved.getId()); } @PostMapping(\"/list/{id}\") public String newItem(@PathVariable(\"id\") Long id, @RequestParam(\"item_text\") String item) { TodoList saved = todoListService.addTodoItem(id, new TodoItem(item)); return redirectToList(saved.getId()); } @GetMapping(\"/list/{list_id}/update/{item_id}\") public String updateItem(@PathVariable(\"list_id\") Long listId, @PathVariable(\"item_id\") Long itemId, @RequestParam(\"finished\") Boolean finished) { return \"\"; // TODO: Implement me! } // TODO: Create a method named deleteItem() that will remove a todo item from a todo list. // The arguments can be similar to the updateItem() above. @ExceptionHandler public String handleException(NoSuchElementException exception) { return \"404\"; } private String redirectToList(Long id) { return String.format(\"redirect:/list/%d\", id); } } Update the test cases for TodoListController in the test code: import com.example.sitodo.model.TodoItem; import com.example.sitodo.model.TodoList; import com.example.sitodo.service.TodoListService; import org.junit.jupiter.api.DisplayName; import org.junit.jupiter.api.Tag; import org.junit.jupiter.api.Test; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest; import org.springframework.boot.test.mock.mockito.MockBean; import org.springframework.test.web.servlet.MockMvc; import java.util.List; import java.util.NoSuchElementException; import static java.nio.charset.StandardCharsets.UTF_8; import static org.hamcrest.Matchers.*; import static org.mockito.ArgumentMatchers.anyBoolean; import static org.mockito.ArgumentMatchers.anyLong; import static org.mockito.Mockito.mock; import static org.mockito.Mockito.when; import static org.springframework.http.MediaType.TEXT_HTML; import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get; import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*; @WebMvcTest(TodoListController.class) class TodoListControllerTest { @Autowired private MockMvc mockMvc; @MockBean private TodoListService todoListService; @Test @DisplayName(\"HTTP GET '/list' retrieves list view\") void showList_resolvesToIndex() throws Exception { mockMvc.perform(get(\"/list\")).andExpectAll( status().isOk(), content().contentTypeCompatibleWith(TEXT_HTML), content().encoding(UTF_8), view().name(\"list\") ); } @Test @DisplayName(\"HTTP GET '/list' returns an HTML page\") void showList_returnsHtml() throws Exception { mockMvc.perform(get(\"/list\")).andExpectAll( status().isOk(), content().contentTypeCompatibleWith(TEXT_HTML), content().encoding(UTF_8), content().string(containsString(\"</html>\")) ); } @Test @DisplayName(\"HTTP GET '/list/{id}' returns an HTML page with non-empty list\") void showList_byId_returnsHtml() throws Exception { TodoItem mockTodoItem = createMockTodoItem(1L, \"Buy milk\"); TodoList mockList = mock(TodoList.class); when(mockList.getId()).thenReturn(1L); when(mockList.getItems()).thenReturn(List.of(mockTodoItem)); when(todoListService.getTodoListById(anyLong())).thenReturn(mockList); mockMvc.perform(get(\"/list/1\")).andExpectAll( status().isOk(), content().contentTypeCompatibleWith(TEXT_HTML), content().encoding(UTF_8), content().string(containsString(\"<table\")), content().string(containsString(\"<tr\")), content().string(containsString(\"Buy milk\")), content().string(containsString(\"</html>\")) ); } @Test @DisplayName(\"Suppose the given ID does not exist, HTTP GET '/list/{id}' returns an error page\") void showList_byId_notFound() throws Exception { when(todoListService.getTodoListById(anyLong())).thenThrow(NoSuchElementException.class); mockMvc.perform(get(\"/list/1\")).andExpectAll( content().string(containsString(\"Not Found\")) ); } @Test @DisplayName(\"HTTP GET '/list/{id}/update/{item_id}' successfully updated status of an item\") void updateItem_ok() throws Exception { // TODO: Implement me! } // TODO: Create the tests for ensuring the correctness of deleteItem() method from the controller. private TodoList createMockTodoList(Long id, TodoItem ... items) { TodoList mockTodoList = mock(TodoList.class); when(mockTodoList.getId()).thenReturn(id); when(mockTodoList.getItems()).thenReturn(List.of(items)); return mockTodoList; } private TodoItem createMockTodoItem(Long id, String title) { TodoItem mockTodoItem = mock(TodoItem.class); when(mockTodoItem.getId()).thenReturn(id); when(mockTodoItem.getTitle()).thenReturn(title); when(mockTodoItem.getFinished()).thenCallRealMethod(); return mockTodoItem; } } Similar to the previous layer, there are some TODO comments and methods need to be implemented. View Update list.html view in the templates directory with the updated HTML: <!doctype html> <html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\"> <head> <meta charset=\"utf-8\"/> <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"/> <link th:rel=\"stylesheet\" th:href=\"@{/webjars/bootstrap/5.1.3/dist/css/bootstrap.css}\"/> <title>Sitodo</title> </head> <body> <div class=\"container\"> <header class=\"d-flex flex-wrap justify-content-center py-3 mb-4 border-bottom\"> <a th:href=\"@{${todoList.id != null} ? '/list/' + ${todoList.id} : '/list'}\" class=\"d-flex align-items-center mb-3 mb-md-0 me-md-auto text-dark text-decoration-none\"> <img class=\"bi me-2\" src=\"/images/logo_placeholder.png\" width=\"160\" height=\"40\" alt=\"logo\"/> <span class=\"fs-4\">SITODO</span> </a> </header> <table id=\"id_list_table\" class=\"table caption-top\"> <caption class=\"display-1\">Your Todo List</caption> <thead class=\"table-dark\"> <tr> <th scope=\"col\">ID</th> <th scope=\"col\">Title</th> <th scope=\"col\">Status</th> <th scope=\"col\">Update</th> <th scope=\"col\">Delete</th> </tr> </thead> <tbody> <tr th:if=\"${todoList.id != null}\" th:each=\"item : ${todoList.items}\"> <td th:text=\"${item.id}\">1</td> <td th:text=\"${item.title}\">Cook rice</td> <td th:text=\"${item.finished} ? 'Finished' : 'Not Finished'\">Not Finished</td> <td th:if=\"${item.finished}\"> <a class=\"sitodo-finish-link\" th:href=\"@{/list/{list_id}/update/{item_id}(list_id=${todoList.id},item_id=${item.id},finished='false')}\"> <span>Mark as 'Not Finished'</span> </a> </td> <td th:unless=\"${item.finished}\"> <a class=\"sitodo-finish-link\" th:href=\"@{/list/{list_id}/update/{item_id}(list_id=${todoList.id},item_id=${item.id},finished='true')}\"> <span>Mark as 'Finished'</span> </a> </td> <td> <a class=\"sitodo-finish-link\"> <!-- TODO: Implement a link that will trigger the delete todo item operation on the controller --> <span>Delete</span> </a> </td> </tr> </tbody> <tfoot> <tr> <td colspan=\"4\"> <p id=\"motivation_message\" th:text=\"${motivationMessage}\">A motivation message</p> </td> </tr> </tfoot> </table> <form th:action=\"@{${todoList.id != null} ? '/list/' + ${todoList.id} : '/list'}\" method=\"post\"> <input type=\"text\" id=\"id_new_item\" name=\"item_text\" placeholder=\"Enter an item\"/> <button type=\"submit\" class=\"btn btn-primary btn-sm\">Enter</button> </form> </div> <script th:src=\"@{/webjars/bootstrap/5.1.3/dist/js/bootstrap.bundle.js}\"></script> </body> </html> The Big Assignment You have seen that there are several TODO comments and methods that are empty or need to be resolved. Your task in this section is to resolve all TODO comments and implement methods that are still empty. Since you are working in a feature branch, any commits you pushed will not break the app that is currently running on Heroku. At the end of the task, make a Pull Request that will merge todo-list-v2 branch into the main branch. Make sure ci workflow still passes before merging the branch! After you merged todo-list-v2 into the main branch, switch back to the main branch in your local Git repository and pull the latest commit from GitHub: git checkout main git pull # Optional: delete local branch git branch -D todo-list-v2","title":"One of Many Lists"},{"location":"bootcamp/day-2/update-data-model/#one-of-many-lists","text":"Today you will update the application by making the user able to create multiple lists each time they open the app. At the same time, you will practice a Git workflow called Feature Branch workflow. First, make sure your local Git repository has the same history as the remote Git repository on GitHub. If you have any Git commits that have not been pushed to GitHub, please commit them now. Similarly, if you made changes on GitHub, ensure the Git commit history is pulled into your local Git repository. # Push commits git push origin main # Pull commits from remote Git repository into the currently active branch git pull origin main According to Feature Branch workflow, any new changes to the codebase should be done in a separate branch from the main branch. Once the changes have been tested, the branch is merged into the main branch. This is to ensure any ongoing development will not break the application that built from the main branch.","title":"One of Many Lists"},{"location":"bootcamp/day-2/update-data-model/#data-persistence-layer","text":"Let us start from the data persistence layer. Open a shell (or terminal in the IDE) and create a new branch named todo-list-v2 using git branch and git checkout commands: git branch todo-list-v2 git checkout todo-list-v2 # Or shorter form: git checkout -b todo-list-v2 Open model package in the production code and update TodoItem class with following code snippets: // TodoItem.java import lombok.Data; import lombok.NoArgsConstructor; import javax.persistence.*; @Data @Entity @NoArgsConstructor public class TodoItem { @Id @GeneratedValue(strategy = GenerationType.SEQUENCE) private Long id; @Column(nullable = false) private String title; @Column private Boolean finished = Boolean.FALSE; public TodoItem(String title) { this.title = title; } public TodoItem(Long id, String title) { this.id = id; this.title = title; } } Then, add a new model class named TodoList in the same model package as TodoItem class: import lombok.Data; import lombok.NoArgsConstructor; import javax.persistence.*; import java.util.List; @Data @Entity @NoArgsConstructor public class TodoList { @Id @GeneratedValue(strategy = GenerationType.SEQUENCE) private Long id; @OneToMany(cascade = {CascadeType.PERSIST, CascadeType.MERGE}) private List<TodoItem> items; public TodoList(List<TodoItem> items) { this.items= items; } public void addTodoItem(TodoItem item) { items.add(item); } } Based on the new data model, all instances of TodoItem will be associated to a TodoList . Or in other words, a TodoList will have one-to-many relationship to TodoItem . Certainly, this will require you to update the code across every layer.","title":"Data Persistence Layer"},{"location":"bootcamp/day-2/update-data-model/#repository-layer","text":"Open repository package in the production code and update TodoListRepository class with following code snippets: import org.springframework.data.repository.CrudRepository; import org.springframework.stereotype.Repository; @Repository public interface TodoListRepository extends CrudRepository<TodoList, Long> { } Based on the change above, TodoItem was replaced with TodoList . All queries for querying todo items will use the one-to-many relationship mapping possessed by TodoList .","title":"Repository Layer"},{"location":"bootcamp/day-2/update-data-model/#service-layer","text":"Open service package in the production code and update TodoListService class with following code snippets: import com.example.sitodo.model.TodoItem; import com.example.sitodo.model.TodoList; import com.example.sitodo.repository.TodoListRepository; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.beans.factory.annotation.Value; import org.springframework.stereotype.Service; import java.util.List; import java.util.NoSuchElementException; import java.util.Optional; @Service public class TodoListService { private static final Logger LOG = LoggerFactory.getLogger(TodoListService.class); private static final String TODO_LIST_DOES_NOT_EXIST_FMT = \"TodoList(id=%d) does not exist\"; private TodoListRepository todoListRepository; @Autowired public void setTodoListRepository(TodoListRepository todoListRepository) { this.todoListRepository = todoListRepository; } public TodoList getTodoListById(Long id) throws NoSuchElementException { Optional<TodoList> result = todoListRepository.findById(id); return result.get(); } public TodoList addTodoItem(TodoItem todoItem) { TodoList list = new TodoList(List.of(todoItem)); return todoListRepository.save(list); } public TodoList addTodoItem(Long id, TodoItem todoItem) throws NoSuchElementException { Optional<TodoList> result = todoListRepository.findById(id); TodoList foundList = result.get(); foundList.addTodoItem(todoItem); return todoListRepository.save(foundList); } public TodoList updateTodoItem(Long listId, Long itemId, Boolean status) throws NoSuchElementException { Optional<TodoList> result = todoListRepository.findById(listId); // TODO: Implement me! return null; } public Boolean deleteTodoItem(Long listId, Long itemId) throws NoSuchElementException { Optional<TodoList> result = todoListRepository.findById(listId); // TODO: Implement me! return Boolean.FALSE; } } Update the test cases for TodoListService in the test code: // TodoListServiceTest.java import org.junit.jupiter.api.DisplayName; import org.junit.jupiter.api.Tag; import org.junit.jupiter.api.Test; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.beans.factory.annotation.Value; import org.springframework.boot.test.context.SpringBootTest; import org.springframework.boot.test.mock.mockito.MockBean; import java.util.*; import java.util.stream.IntStream; import static org.hamcrest.MatcherAssert.assertThat; import static org.hamcrest.Matchers.*; import static org.junit.jupiter.api.Assertions.*; import static org.mockito.ArgumentMatchers.any; import static org.mockito.ArgumentMatchers.anyLong; import static org.mockito.Mockito.mock; import static org.mockito.Mockito.when; @SpringBootTest class TodoListServiceTest { @Autowired private TodoListService todoListService; @MockBean private TodoListRepository todoListRepository; @Test @DisplayName(\"Given an existing ID, getTodoListById should return an existing list\") void getTodoListById_ok() { TodoList todoList = createTodoList(\"Buy milk\"); when(todoListRepository.findById(anyLong())).thenReturn(Optional.of(todoList)); TodoList savedList = todoListService.getTodoListById(1L); assertFalse(savedList.getItems().isEmpty()); } @Test @DisplayName(\"Suppose the list does not exist, getTodoListById should throw an exception\") void getTodoListById_exception() { when(todoListRepository.findById(anyLong())).thenReturn(Optional.empty()); assertThrows(NoSuchElementException.class, () -> todoListService.getTodoListById(1L)); } @Test @DisplayName(\"Given a new todo item, addTodoItem should save the item into a new list\") void addTodoItem_ok() { TodoItem todoItem = new TodoItem(\"Buy milk\"); when(todoListRepository.save(any(TodoList.class))).thenReturn(new TodoList(List.of(todoItem))); TodoList savedList = todoListService.addTodoItem(todoItem); TodoItem savedTodoItem = savedList.getItems().get(0); assertFalse(savedList.getItems().isEmpty()); assertEquals(\"Buy milk\", savedTodoItem.getTitle()); } @Test @DisplayName(\"Given a todo item, addTodoItem should save the item into an existing list\") void addTodoItem_existingList_ok() { TodoList list = createTodoList(\"Buy milk\"); when(todoListRepository.findById(anyLong())).thenReturn(Optional.of(list)); todoListService.addTodoItem(1L, new TodoItem(\"Touch grass\")); assertEquals(2, list.getItems().size(), \"The numbers of items in the list: \" + list.getItems().size()); } @Test @DisplayName(\"Suppose the list does not exist, addTodoItem should throw an exception\") void addTodoItem_existingList_exception() { when(todoListRepository.findById(anyLong())).thenReturn(Optional.empty()); assertThrows(NoSuchElementException.class, () -> todoListService.addTodoItem(1L, new TodoItem(\"Buy milk\"))); } @Test @DisplayName(\"Given an existing list with an item, updateTodoItem should update the status of an item\") void updateTodoItem_ok() { // TODO: Implement me! } @Test @DisplayName(\"Suppose the list does not exist, updateTodoItem should throw an exception\") void updateTodoItem_exception() { when(todoListRepository.findById(anyLong())).thenReturn(Optional.empty()); assertThrows(NoSuchElementException.class, () -> todoListService.updateTodoItem(1L, 2L, true)); } // TODO: Create tests for deleteTodoItem private TodoList createTodoList(String... items) { TodoList list = new TodoList(new ArrayList<>()); Arrays.stream(items) .map(TodoItem::new) .forEach(list::addTodoItem); return list; } } Notice that there are several methods and TODO comments that need to be resolved.","title":"Service Layer"},{"location":"bootcamp/day-2/update-data-model/#controller","text":"Open controller package in the production code and update TodoListController class with following code snippets: // TodoListController.java import com.example.sitodo.model.TodoItem; import com.example.sitodo.model.TodoList; import com.example.sitodo.service.TodoListService; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Controller; import org.springframework.ui.Model; import org.springframework.web.bind.annotation.*; import java.util.NoSuchElementException; @Controller public class TodoListController { private static final Logger LOG = LoggerFactory.getLogger(TodoListController.class); private TodoListService todoListService; @Autowired public void setTodoListService(TodoListService todoListService) { this.todoListService = todoListService; } @GetMapping(\"/list\") public String showList(TodoList todoList, Model model) { model.addAttribute(\"todoList\", todoList); return \"list\"; } @GetMapping(\"/list/{id}\") public String showList(@PathVariable(\"id\") Long id, Model model) { TodoList foundTodoList = todoListService.getTodoListById(id); model.addAttribute(\"todoList\", foundTodoList); return \"list\"; } @PostMapping(\"/list\") public String newItem(@RequestParam(\"item_text\") String item) { TodoList saved = todoListService.addTodoItem(new TodoItem(item)); return redirectToList(saved.getId()); } @PostMapping(\"/list/{id}\") public String newItem(@PathVariable(\"id\") Long id, @RequestParam(\"item_text\") String item) { TodoList saved = todoListService.addTodoItem(id, new TodoItem(item)); return redirectToList(saved.getId()); } @GetMapping(\"/list/{list_id}/update/{item_id}\") public String updateItem(@PathVariable(\"list_id\") Long listId, @PathVariable(\"item_id\") Long itemId, @RequestParam(\"finished\") Boolean finished) { return \"\"; // TODO: Implement me! } // TODO: Create a method named deleteItem() that will remove a todo item from a todo list. // The arguments can be similar to the updateItem() above. @ExceptionHandler public String handleException(NoSuchElementException exception) { return \"404\"; } private String redirectToList(Long id) { return String.format(\"redirect:/list/%d\", id); } } Update the test cases for TodoListController in the test code: import com.example.sitodo.model.TodoItem; import com.example.sitodo.model.TodoList; import com.example.sitodo.service.TodoListService; import org.junit.jupiter.api.DisplayName; import org.junit.jupiter.api.Tag; import org.junit.jupiter.api.Test; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest; import org.springframework.boot.test.mock.mockito.MockBean; import org.springframework.test.web.servlet.MockMvc; import java.util.List; import java.util.NoSuchElementException; import static java.nio.charset.StandardCharsets.UTF_8; import static org.hamcrest.Matchers.*; import static org.mockito.ArgumentMatchers.anyBoolean; import static org.mockito.ArgumentMatchers.anyLong; import static org.mockito.Mockito.mock; import static org.mockito.Mockito.when; import static org.springframework.http.MediaType.TEXT_HTML; import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get; import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*; @WebMvcTest(TodoListController.class) class TodoListControllerTest { @Autowired private MockMvc mockMvc; @MockBean private TodoListService todoListService; @Test @DisplayName(\"HTTP GET '/list' retrieves list view\") void showList_resolvesToIndex() throws Exception { mockMvc.perform(get(\"/list\")).andExpectAll( status().isOk(), content().contentTypeCompatibleWith(TEXT_HTML), content().encoding(UTF_8), view().name(\"list\") ); } @Test @DisplayName(\"HTTP GET '/list' returns an HTML page\") void showList_returnsHtml() throws Exception { mockMvc.perform(get(\"/list\")).andExpectAll( status().isOk(), content().contentTypeCompatibleWith(TEXT_HTML), content().encoding(UTF_8), content().string(containsString(\"</html>\")) ); } @Test @DisplayName(\"HTTP GET '/list/{id}' returns an HTML page with non-empty list\") void showList_byId_returnsHtml() throws Exception { TodoItem mockTodoItem = createMockTodoItem(1L, \"Buy milk\"); TodoList mockList = mock(TodoList.class); when(mockList.getId()).thenReturn(1L); when(mockList.getItems()).thenReturn(List.of(mockTodoItem)); when(todoListService.getTodoListById(anyLong())).thenReturn(mockList); mockMvc.perform(get(\"/list/1\")).andExpectAll( status().isOk(), content().contentTypeCompatibleWith(TEXT_HTML), content().encoding(UTF_8), content().string(containsString(\"<table\")), content().string(containsString(\"<tr\")), content().string(containsString(\"Buy milk\")), content().string(containsString(\"</html>\")) ); } @Test @DisplayName(\"Suppose the given ID does not exist, HTTP GET '/list/{id}' returns an error page\") void showList_byId_notFound() throws Exception { when(todoListService.getTodoListById(anyLong())).thenThrow(NoSuchElementException.class); mockMvc.perform(get(\"/list/1\")).andExpectAll( content().string(containsString(\"Not Found\")) ); } @Test @DisplayName(\"HTTP GET '/list/{id}/update/{item_id}' successfully updated status of an item\") void updateItem_ok() throws Exception { // TODO: Implement me! } // TODO: Create the tests for ensuring the correctness of deleteItem() method from the controller. private TodoList createMockTodoList(Long id, TodoItem ... items) { TodoList mockTodoList = mock(TodoList.class); when(mockTodoList.getId()).thenReturn(id); when(mockTodoList.getItems()).thenReturn(List.of(items)); return mockTodoList; } private TodoItem createMockTodoItem(Long id, String title) { TodoItem mockTodoItem = mock(TodoItem.class); when(mockTodoItem.getId()).thenReturn(id); when(mockTodoItem.getTitle()).thenReturn(title); when(mockTodoItem.getFinished()).thenCallRealMethod(); return mockTodoItem; } } Similar to the previous layer, there are some TODO comments and methods need to be implemented.","title":"Controller"},{"location":"bootcamp/day-2/update-data-model/#view","text":"Update list.html view in the templates directory with the updated HTML: <!doctype html> <html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\"> <head> <meta charset=\"utf-8\"/> <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"/> <link th:rel=\"stylesheet\" th:href=\"@{/webjars/bootstrap/5.1.3/dist/css/bootstrap.css}\"/> <title>Sitodo</title> </head> <body> <div class=\"container\"> <header class=\"d-flex flex-wrap justify-content-center py-3 mb-4 border-bottom\"> <a th:href=\"@{${todoList.id != null} ? '/list/' + ${todoList.id} : '/list'}\" class=\"d-flex align-items-center mb-3 mb-md-0 me-md-auto text-dark text-decoration-none\"> <img class=\"bi me-2\" src=\"/images/logo_placeholder.png\" width=\"160\" height=\"40\" alt=\"logo\"/> <span class=\"fs-4\">SITODO</span> </a> </header> <table id=\"id_list_table\" class=\"table caption-top\"> <caption class=\"display-1\">Your Todo List</caption> <thead class=\"table-dark\"> <tr> <th scope=\"col\">ID</th> <th scope=\"col\">Title</th> <th scope=\"col\">Status</th> <th scope=\"col\">Update</th> <th scope=\"col\">Delete</th> </tr> </thead> <tbody> <tr th:if=\"${todoList.id != null}\" th:each=\"item : ${todoList.items}\"> <td th:text=\"${item.id}\">1</td> <td th:text=\"${item.title}\">Cook rice</td> <td th:text=\"${item.finished} ? 'Finished' : 'Not Finished'\">Not Finished</td> <td th:if=\"${item.finished}\"> <a class=\"sitodo-finish-link\" th:href=\"@{/list/{list_id}/update/{item_id}(list_id=${todoList.id},item_id=${item.id},finished='false')}\"> <span>Mark as 'Not Finished'</span> </a> </td> <td th:unless=\"${item.finished}\"> <a class=\"sitodo-finish-link\" th:href=\"@{/list/{list_id}/update/{item_id}(list_id=${todoList.id},item_id=${item.id},finished='true')}\"> <span>Mark as 'Finished'</span> </a> </td> <td> <a class=\"sitodo-finish-link\"> <!-- TODO: Implement a link that will trigger the delete todo item operation on the controller --> <span>Delete</span> </a> </td> </tr> </tbody> <tfoot> <tr> <td colspan=\"4\"> <p id=\"motivation_message\" th:text=\"${motivationMessage}\">A motivation message</p> </td> </tr> </tfoot> </table> <form th:action=\"@{${todoList.id != null} ? '/list/' + ${todoList.id} : '/list'}\" method=\"post\"> <input type=\"text\" id=\"id_new_item\" name=\"item_text\" placeholder=\"Enter an item\"/> <button type=\"submit\" class=\"btn btn-primary btn-sm\">Enter</button> </form> </div> <script th:src=\"@{/webjars/bootstrap/5.1.3/dist/js/bootstrap.bundle.js}\"></script> </body> </html>","title":"View"},{"location":"bootcamp/day-2/update-data-model/#the-big-assignment","text":"You have seen that there are several TODO comments and methods that are empty or need to be resolved. Your task in this section is to resolve all TODO comments and implement methods that are still empty. Since you are working in a feature branch, any commits you pushed will not break the app that is currently running on Heroku. At the end of the task, make a Pull Request that will merge todo-list-v2 branch into the main branch. Make sure ci workflow still passes before merging the branch! After you merged todo-list-v2 into the main branch, switch back to the main branch in your local Git repository and pull the latest commit from GitHub: git checkout main git pull # Optional: delete local branch git branch -D todo-list-v2","title":"The Big Assignment"}]}