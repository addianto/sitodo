{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Developing Sitodo From Zero A training course for developing a simple todo list Web application using Java and Spring Boot framework. Description This is a training course for teaching students on how to develop a Web application using Java programming language and Spring Boot framework, with focus on applying test-first approach and continuous integration/continuous deployment (CI/CD). Learning Outcomes By the end of this course, students should be able to: Apply a workflow when using a version control system such as Git Develop a simple Web application using Java programming language and Spring Boot framework backed by a relational database. Create tests for verifying the Web application in different levels, such as unit test, integration test, and functional test Set up a Continuous Integration/Continuous Deployment (CI/CD) pipeline using GitHub Actions (or similar platform such as GitLab CI/CD) Target Audience While the course is designed for fresh graduates with a background in computing, students coming from a different background can read and attend the course. At minimum, you need to: Have some experiences in programming, preferably using an object-oriented language Understand relational data modeling and SQL operations Know Web design and familiar with the related technologies such as HTML, basic JavaScript, and CSS Know basic Linux shell scripting (e.g. bash ) or its equivalent on Windows (e.g. cmd or pwsh ) Requirements To complete this course, you need a computing device that can run the following development tools: A shell, such as bash on Linux or Mac OS, or cmd / pwsh on Windows Latest long-term support (LTS) version (i.e. Java 17 at the time of writing) of Java Development Kit (JDK), preferably from Adoptium . IntelliJ IDEA Community Edition by JetBrains PostgreSQL database system version 14 Note: While you can use other text editors (e.g. Visual Studio Code) or IDE such as Eclipse or NetBeans, we might not be able to troubleshoot any problems that come up during the course In addition, you also need to have an account on the following online services: GitHub an online source code repository and project management system Heroku a Platform-as-a-Service (PaaS) for deploying the Web application Course Outlines The course will include: Set up local development environment Initialise up a Spring Boot project Introduction to test-driven development (TDD) Create a continuous integration and deployment pipeline (CI/CD) There will be some additional challenges for participants, such as: Develop functional test using Selenium Implement basic user authentication using Spring Security Migrate deployment to a different PaaS provider such as Fly.io You can proceed to the contents for Day 1 . License The learning materials in this course are licensed under Creative Commons Attribution-ShareAlike 4.0 ( CC BY-SA 4.0 ). You can reuse, modify, distribute, and do pretty much anything with the course materials as long as it is permitted under the terms of the license.","title":"Course Overview"},{"location":"#developing-sitodo-from-zero","text":"A training course for developing a simple todo list Web application using Java and Spring Boot framework.","title":"Developing Sitodo From Zero"},{"location":"#description","text":"This is a training course for teaching students on how to develop a Web application using Java programming language and Spring Boot framework, with focus on applying test-first approach and continuous integration/continuous deployment (CI/CD).","title":"Description"},{"location":"#learning-outcomes","text":"By the end of this course, students should be able to: Apply a workflow when using a version control system such as Git Develop a simple Web application using Java programming language and Spring Boot framework backed by a relational database. Create tests for verifying the Web application in different levels, such as unit test, integration test, and functional test Set up a Continuous Integration/Continuous Deployment (CI/CD) pipeline using GitHub Actions (or similar platform such as GitLab CI/CD)","title":"Learning Outcomes"},{"location":"#target-audience","text":"While the course is designed for fresh graduates with a background in computing, students coming from a different background can read and attend the course. At minimum, you need to: Have some experiences in programming, preferably using an object-oriented language Understand relational data modeling and SQL operations Know Web design and familiar with the related technologies such as HTML, basic JavaScript, and CSS Know basic Linux shell scripting (e.g. bash ) or its equivalent on Windows (e.g. cmd or pwsh )","title":"Target Audience"},{"location":"#requirements","text":"To complete this course, you need a computing device that can run the following development tools: A shell, such as bash on Linux or Mac OS, or cmd / pwsh on Windows Latest long-term support (LTS) version (i.e. Java 17 at the time of writing) of Java Development Kit (JDK), preferably from Adoptium . IntelliJ IDEA Community Edition by JetBrains PostgreSQL database system version 14 Note: While you can use other text editors (e.g. Visual Studio Code) or IDE such as Eclipse or NetBeans, we might not be able to troubleshoot any problems that come up during the course In addition, you also need to have an account on the following online services: GitHub an online source code repository and project management system Heroku a Platform-as-a-Service (PaaS) for deploying the Web application","title":"Requirements"},{"location":"#course-outlines","text":"The course will include: Set up local development environment Initialise up a Spring Boot project Introduction to test-driven development (TDD) Create a continuous integration and deployment pipeline (CI/CD) There will be some additional challenges for participants, such as: Develop functional test using Selenium Implement basic user authentication using Spring Security Migrate deployment to a different PaaS provider such as Fly.io You can proceed to the contents for Day 1 .","title":"Course Outlines"},{"location":"#license","text":"The learning materials in this course are licensed under Creative Commons Attribution-ShareAlike 4.0 ( CC BY-SA 4.0 ). You can reuse, modify, distribute, and do pretty much anything with the course materials as long as it is permitted under the terms of the license.","title":"License"},{"location":"toc/","text":"Table of Contents Course Setup Install Git Reminder about newlines, i.e. git config --global auto.crlf input , and install EditorConfig Install Java Ensure JAVA_HOME and PATH configured properly Install IDE (IntelliJ) Set up GitHub account Set up Heroku / Fly.io account At the end, verify all tools have been installed, e.g. git --version Project Scaffolding Use Spring Initializr Initialise Git repository in local development environment Create a new online Git repository on GitHub Update README.md Create a first commit Set up a new Git remote from local repository to online repository on GitHub Push local Git history to the online repository Implement Landing Page (Hello, World) Introduction to test-driven development (TDD) Inside-out TDD part 1: pure unit test Create an HTML page for the landing page with custom greeting from GET request Create a unit test for the controller class Inside-out TDD part 2: unit test in mocked environment using @MockMvc and @SpringBootTest Create a unit test with mock for the controller class Inside-out TDD part 3: functional test with Selenium (Optional) Quality Assurance & Test Automation Deploy the app manually using Heroku or Fly.io CLI tool Automate test suite execution using GitHub Actions on GitHub Automate deployment using GitHub Actions on GitHub Code quality analysis using GitHub Actions on GitHub (Optional) Implement Todo List Implement data persistence layer Create model class using JPA Create migration script using Liquibase Implement business logic layer Create a service class Write a unit test for service class Implement presentation layer Create a controller class Write a unit test for controller class Create a Web page using HTML and Thymeleaf template syntax Extra Challenge: Personalised Todo List with Authentication Define user authentication model Update database schema via database migration Secure the existing todo list behind authentication Extra Challenge: PostgreSQL Database Install PostgreSQL on development and deployment environments Local installation options: system-wide (using installer) or container (Docker) Installation options on PaaS: Heroku Addon (Heroku) or flyctl (Fly.io)","title":"Table of Contents"},{"location":"toc/#table-of-contents","text":"","title":"Table of Contents"},{"location":"toc/#course-setup","text":"Install Git Reminder about newlines, i.e. git config --global auto.crlf input , and install EditorConfig Install Java Ensure JAVA_HOME and PATH configured properly Install IDE (IntelliJ) Set up GitHub account Set up Heroku / Fly.io account At the end, verify all tools have been installed, e.g. git --version","title":"Course Setup"},{"location":"toc/#project-scaffolding","text":"Use Spring Initializr Initialise Git repository in local development environment Create a new online Git repository on GitHub Update README.md Create a first commit Set up a new Git remote from local repository to online repository on GitHub Push local Git history to the online repository","title":"Project Scaffolding"},{"location":"toc/#implement-landing-page-hello-world","text":"Introduction to test-driven development (TDD) Inside-out TDD part 1: pure unit test Create an HTML page for the landing page with custom greeting from GET request Create a unit test for the controller class Inside-out TDD part 2: unit test in mocked environment using @MockMvc and @SpringBootTest Create a unit test with mock for the controller class Inside-out TDD part 3: functional test with Selenium (Optional)","title":"Implement Landing Page (Hello, World)"},{"location":"toc/#quality-assurance-test-automation","text":"Deploy the app manually using Heroku or Fly.io CLI tool Automate test suite execution using GitHub Actions on GitHub Automate deployment using GitHub Actions on GitHub Code quality analysis using GitHub Actions on GitHub (Optional)","title":"Quality Assurance &amp; Test Automation"},{"location":"toc/#implement-todo-list","text":"Implement data persistence layer Create model class using JPA Create migration script using Liquibase Implement business logic layer Create a service class Write a unit test for service class Implement presentation layer Create a controller class Write a unit test for controller class Create a Web page using HTML and Thymeleaf template syntax","title":"Implement Todo List"},{"location":"toc/#extra-challenge-personalised-todo-list-with-authentication","text":"Define user authentication model Update database schema via database migration Secure the existing todo list behind authentication","title":"Extra Challenge: Personalised Todo List with Authentication"},{"location":"toc/#extra-challenge-postgresql-database","text":"Install PostgreSQL on development and deployment environments Local installation options: system-wide (using installer) or container (Docker) Installation options on PaaS: Heroku Addon (Heroku) or flyctl (Fly.io)","title":"Extra Challenge: PostgreSQL Database"},{"location":"bootcamp/day-1/","text":"Bootcamp (Day 1) Still in development. Stay tune!","title":"Bootcamp (Day 1)"},{"location":"bootcamp/day-1/#bootcamp-day-1","text":"Still in development. Stay tune!","title":"Bootcamp (Day 1)"},{"location":"bootcamp/day-1/basic-list/","text":"Create a Basic Todo List Data Persistence Layer Create a new class named TodoItem in the production code, specifically in a new package named model : import lombok.Data; import lombok.NoArgsConstructor; import javax.persistence.*; @Data @Entity @NoArgsConstructor public class TodoItem { @Id @GeneratedValue(strategy = GenerationType.SEQUENCE) private Long id; @Column(nullable = false) private String title; @Column private Boolean finished = Boolean.FALSE; public TodoItem(String title) { this.title = title; } public TodoItem(Long id, String title) { this.id = id; this.title = title; } } Repository Layer Create a new Java interface named TodoListRepository that extends CrudRepository interface provided by Spring JPA. Put the new Java interface in a new package called repository in the production code. We will use it to implement a data access layer in between the data model and business logic layers. The TodoListRepository implementation is short and can be seen in the following code snippet: // Removed some import statements for brevity. import org.springframework.data.repository.CrudRepository; import org.springframework.stereotype.Repository; @Repository public interface TodoListRepository extends CrudRepository<TodoList, Long> { } Service Layer Create a new package called service in the production code. Then, create a new class named TodoListService in the new package. We will use service package to contain classes related to service layer of the app, i.e. classes that provide implementations related to business logic. The content of TodoListService is as follows: // Removed some import statements for brevity. import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Service; import java.util.List; @Service public class TodoListService { private TodoListRepository todoListRepository; @Autowired public void setTodoListRepository(TodoListRepository todoListRepository) { this.todoListRepository = todoListRepository; } } Since we will implement a basic todo list that shows a list of todo items, we need to implement methods that can add and retrieve todo items: public class TodoListService { // Omitted for brevity private TodoListRepository todoListRepository; public List<TodoItem> getTodoItems() { return todoListRepository.findAll(); } public TodoItem addTodoItem(TodoItem todoItem) { return todoListRepository.save(todoItem); } } Test Initial Implementation You might question: \"Do we need to test the repository and service classes?\" The implementation of both layers is quite simple at this point, so one might wonder if it is worth testing them. The repository layer can be left untested at the moment because we did not customise the inherited implementation. The service layer, however, needs to be tested because it is related to business logic that is domain-specific to the problem. Create a new class named TodoListService in the test code and ensure the package structure follows the production code. In the new class, implement the test cases that verify the expected correct behaviour of both getTodoItems and addTodoItem : import com.example.sitodo.model.TodoItem; import com.example.sitodo.repository.TodoListRepository; import org.junit.jupiter.api.Test; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.context.SpringBootTest; import org.springframework.boot.test.mock.mockito.MockBean; import static org.mockito.ArgumentMatchers.any; import static org.mockito.Mockito.when; @SpringBootTest class TodoListServiceTest { @Autowired private TodoListService todoListService; @MockBean private TodoListRepository todoListRepository; @Test void getTodoItems_someItems_ok() { when(todoListRepository.findAll()).thenReturn(List.of( new TodoItem(\"A\"), new TodoItem(\"B\"), new TodoItem(\"C\") )); List<TodoItem> todoItems = todoListService.findAll(); assertEquals(3, todoItems.size()); } @Test void addTodoItem_ok() { TodoItem todoItem = new TodoItem(\"Buy milk\"); when(todoListRepository.save(any(TodoItem.class))).thenReturn(todoItem); TodoItem savedTodoItem = todoListService.addTodoItem(todoItem); assertEquals(\"Buy milk\", savedTodoItem.getTitle()); } } Maybe you noticed that the tests look different from the one you created in the previous section. The tests above implement a mock object that serves as a stand-in of an actual object during testing. The mock object can be configured to simulate a behaviour specific during testing. We use a mock object to ensure the test in the service layer is independent of the repository layer. Back to Controller and View You have implemented the business logic of adding and listing a todo list. The next step is to implement the controller to handle requests from the user. But before that, in spirit of TDD, let us create a test first. Let us start by implementing a method to retrieve the todo list. Create a new class named TodoListControllerTest in the test code: You know where to put it, right? Controller classes go into controller package. Maintain proper separation of concern in your codebase! // Removed some import statements for brevity. import org.junit.jupiter.api.Test; import org.junit.jupiter.api.DisplayName; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest; import org.springframework.boot.test.mock.mockito.MockBean; import org.springframework.test.web.servlet.MockMvc; import static java.nio.charset.StandardCharsets.UTF_8; import static org.hamcrest.Matchers.*; import static org.mockito.ArgumentMatchers.anyBoolean; import static org.mockito.ArgumentMatchers.anyLong; import static org.mockito.Mockito.mock; import static org.mockito.Mockito.when; import static org.springframework.http.MediaType.TEXT_HTML; import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get; import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*; @WebMvcTest(TodoListController.class) @Tag(\"unit\") class TodoListControllerTest { @Autowired private MockMvc mockMvc; @MockBean private TodoListService todoListService; // New annotation! // @DisplayName allows you to customise the name of a test case. @Test @DisplayName(\"HTTP GET '/list' retrieves list view\") void showList_correctView() throws Exception { mockMvc.perform(get(\"/list\")).andExpectAll( status().isOk(), content().contentTypeCompatibleWith(TEXT_HTML), content().encoding(UTF_8), view().name(\"list\") ); } @Test @DisplayName(\"HTTP GET '/list' returns an HTML page\") void showList_returnHtml() throws Exception { mockMvc.perform(get(\"/list\")).andExpectAll( status().isOk(), content().contentTypeCompatibleWith(TEXT_HTML), content().encoding(UTF_8), content().string(containsString(\"</html>\")) ); } @Test @DisplayName(\"HTTP GET '/list' returns an HTML page with non-empty list\") void showList_withSampleData_ok() throws Exception { TodoItem mockTodoItem = createMockTodoItem(1L, \"Buy milk\"); TodoList mockList = mock(TodoList.class); when(mockList.getId()).thenReturn(1L); when(mockList.getItems()).thenReturn(List.of(mockTodoItem)); when(todoListService.getTodoListById(anyLong())).thenReturn(mockList); mockMvc.perform(get(\"/list\")).andExpectAll( status().isOk(), content().contentTypeCompatibleWith(TEXT_HTML), content().encoding(UTF_8), content().string(containsString(\"Buy milk\")) ); } } Implement the actual controller in the production code: // Removed import statements for brevity @Controller public class TodoListController { private TodoListService todoListService; @Autowired public void setTodoListService(TodoListService todoListService) { this.todoListService = todoListService; } @GetMapping(\"/list\") public String showList(Model model) { List<TodoItem> todoItems = todoListService.getTodoItems(); model.add(\"todoList\", todoItems); return \"list\"; } } Do not forget to create the HTML view of the todo list. Create a new HTML view called list.html in templates directory at src/main/resources : <!doctype html> <html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\"> <head> <meta charset=\"utf-8\"/> <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"/> <link th:rel=\"stylesheet\" th:href=\"@{/webjars/bootstrap/5.1.3/dist/css/bootstrap.css}\"/> <title>Sitodo</title> </head> <body> <div class=\"container\"> <header class=\"d-flex flex-wrap justify-content-center py-3 mb-4 border-bottom\"> <span class=\"fs-4\">SITODO</span> </header> <table id=\"id_list_table\" class=\"table caption-top\"> <caption class=\"display-1\">Your Todo List</caption> <thead class=\"table-dark\"> <tr> <th scope=\"col\">ID</th> <th scope=\"col\">Title</th> <th scope=\"col\">Status</th> </tr> </thead> <tbody> <tr th:each=\"item : ${todoList}\"> <td th:text=\"${item.id}\">1</td> <td th:text=\"${item.title}\">Cook rice</td> <td th:text=\"${item.finished} ? 'Finished' : 'Not Finished'\">Not Finished</td> </tr> </tbody> </table> <form action=\"/list\" method=\"post\"> <input type=\"text\" id=\"id_new_item\" name=\"item_text\" placeholder=\"Enter an item\"/> <button type=\"submit\" class=\"btn btn-primary btn-sm\">Enter</button> </form> </div> <script th:src=\"@{/webjars/bootstrap/5.1.3/dist/js/bootstrap.bundle.js}\"></script> </body> </html> The HTML view example above requires the Bootstrap CSS framework . You can either include Bootstrap from a content delivery network (CDN), or add a new dependency in pom.xml that adds Bootstrap into the project. If you choose to update the project dependencies in pom.xml , use the following Maven dependency that includes Bootstrap: <dependency> <groupId>org.webjars.npm</groupId> <artifactId>bootstrap</artifactId> <version>5.1.3</version> </dependency> Complete the Basic Functionality You have known the overall groundwork required to implement a feature in the TDD approach. The next task is to ensure the user can actually create a new todo item. Now try to work on your own. But do not worry, there will be hints on how to complete it. Your tasks are as follows: Add a new test case in TodoListControllerTest that verifies the correctness of incoming HTTP POST message. Try to figure out how to use MockMvc to simulate an HTTP POST message with a data payload (i.e. the new todo item submitted via an HTML form). Add a new method in TodoListController that handles incoming HTTP POST message containing the new todo item. Use @PostMapping annotation to designate the new method as the handler of an incoming HTTP POST message to /list path. You also need to add a parameter into the method, so you can obtain the new todo item in the HTTP POST message. Try to run the application from time to time. While having test suites that are executed by a test runner is important, do not forget to run the app manually and try using it as an actual user. You can run the app by executing main() method in SitodoApplication class, or by calling mvnw spring-boot:run Maven command. If you have finished, do not forget to save your latest work as a commit and push it to GitHub: git add <path to the changed files> git commit git push","title":"Create a Basic Todo List"},{"location":"bootcamp/day-1/basic-list/#create-a-basic-todo-list","text":"","title":"Create a Basic Todo List"},{"location":"bootcamp/day-1/basic-list/#data-persistence-layer","text":"Create a new class named TodoItem in the production code, specifically in a new package named model : import lombok.Data; import lombok.NoArgsConstructor; import javax.persistence.*; @Data @Entity @NoArgsConstructor public class TodoItem { @Id @GeneratedValue(strategy = GenerationType.SEQUENCE) private Long id; @Column(nullable = false) private String title; @Column private Boolean finished = Boolean.FALSE; public TodoItem(String title) { this.title = title; } public TodoItem(Long id, String title) { this.id = id; this.title = title; } }","title":"Data Persistence Layer"},{"location":"bootcamp/day-1/basic-list/#repository-layer","text":"Create a new Java interface named TodoListRepository that extends CrudRepository interface provided by Spring JPA. Put the new Java interface in a new package called repository in the production code. We will use it to implement a data access layer in between the data model and business logic layers. The TodoListRepository implementation is short and can be seen in the following code snippet: // Removed some import statements for brevity. import org.springframework.data.repository.CrudRepository; import org.springframework.stereotype.Repository; @Repository public interface TodoListRepository extends CrudRepository<TodoList, Long> { }","title":"Repository Layer"},{"location":"bootcamp/day-1/basic-list/#service-layer","text":"Create a new package called service in the production code. Then, create a new class named TodoListService in the new package. We will use service package to contain classes related to service layer of the app, i.e. classes that provide implementations related to business logic. The content of TodoListService is as follows: // Removed some import statements for brevity. import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Service; import java.util.List; @Service public class TodoListService { private TodoListRepository todoListRepository; @Autowired public void setTodoListRepository(TodoListRepository todoListRepository) { this.todoListRepository = todoListRepository; } } Since we will implement a basic todo list that shows a list of todo items, we need to implement methods that can add and retrieve todo items: public class TodoListService { // Omitted for brevity private TodoListRepository todoListRepository; public List<TodoItem> getTodoItems() { return todoListRepository.findAll(); } public TodoItem addTodoItem(TodoItem todoItem) { return todoListRepository.save(todoItem); } }","title":"Service Layer"},{"location":"bootcamp/day-1/basic-list/#test-initial-implementation","text":"You might question: \"Do we need to test the repository and service classes?\" The implementation of both layers is quite simple at this point, so one might wonder if it is worth testing them. The repository layer can be left untested at the moment because we did not customise the inherited implementation. The service layer, however, needs to be tested because it is related to business logic that is domain-specific to the problem. Create a new class named TodoListService in the test code and ensure the package structure follows the production code. In the new class, implement the test cases that verify the expected correct behaviour of both getTodoItems and addTodoItem : import com.example.sitodo.model.TodoItem; import com.example.sitodo.repository.TodoListRepository; import org.junit.jupiter.api.Test; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.context.SpringBootTest; import org.springframework.boot.test.mock.mockito.MockBean; import static org.mockito.ArgumentMatchers.any; import static org.mockito.Mockito.when; @SpringBootTest class TodoListServiceTest { @Autowired private TodoListService todoListService; @MockBean private TodoListRepository todoListRepository; @Test void getTodoItems_someItems_ok() { when(todoListRepository.findAll()).thenReturn(List.of( new TodoItem(\"A\"), new TodoItem(\"B\"), new TodoItem(\"C\") )); List<TodoItem> todoItems = todoListService.findAll(); assertEquals(3, todoItems.size()); } @Test void addTodoItem_ok() { TodoItem todoItem = new TodoItem(\"Buy milk\"); when(todoListRepository.save(any(TodoItem.class))).thenReturn(todoItem); TodoItem savedTodoItem = todoListService.addTodoItem(todoItem); assertEquals(\"Buy milk\", savedTodoItem.getTitle()); } } Maybe you noticed that the tests look different from the one you created in the previous section. The tests above implement a mock object that serves as a stand-in of an actual object during testing. The mock object can be configured to simulate a behaviour specific during testing. We use a mock object to ensure the test in the service layer is independent of the repository layer.","title":"Test Initial Implementation"},{"location":"bootcamp/day-1/basic-list/#back-to-controller-and-view","text":"You have implemented the business logic of adding and listing a todo list. The next step is to implement the controller to handle requests from the user. But before that, in spirit of TDD, let us create a test first. Let us start by implementing a method to retrieve the todo list. Create a new class named TodoListControllerTest in the test code: You know where to put it, right? Controller classes go into controller package. Maintain proper separation of concern in your codebase! // Removed some import statements for brevity. import org.junit.jupiter.api.Test; import org.junit.jupiter.api.DisplayName; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest; import org.springframework.boot.test.mock.mockito.MockBean; import org.springframework.test.web.servlet.MockMvc; import static java.nio.charset.StandardCharsets.UTF_8; import static org.hamcrest.Matchers.*; import static org.mockito.ArgumentMatchers.anyBoolean; import static org.mockito.ArgumentMatchers.anyLong; import static org.mockito.Mockito.mock; import static org.mockito.Mockito.when; import static org.springframework.http.MediaType.TEXT_HTML; import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get; import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*; @WebMvcTest(TodoListController.class) @Tag(\"unit\") class TodoListControllerTest { @Autowired private MockMvc mockMvc; @MockBean private TodoListService todoListService; // New annotation! // @DisplayName allows you to customise the name of a test case. @Test @DisplayName(\"HTTP GET '/list' retrieves list view\") void showList_correctView() throws Exception { mockMvc.perform(get(\"/list\")).andExpectAll( status().isOk(), content().contentTypeCompatibleWith(TEXT_HTML), content().encoding(UTF_8), view().name(\"list\") ); } @Test @DisplayName(\"HTTP GET '/list' returns an HTML page\") void showList_returnHtml() throws Exception { mockMvc.perform(get(\"/list\")).andExpectAll( status().isOk(), content().contentTypeCompatibleWith(TEXT_HTML), content().encoding(UTF_8), content().string(containsString(\"</html>\")) ); } @Test @DisplayName(\"HTTP GET '/list' returns an HTML page with non-empty list\") void showList_withSampleData_ok() throws Exception { TodoItem mockTodoItem = createMockTodoItem(1L, \"Buy milk\"); TodoList mockList = mock(TodoList.class); when(mockList.getId()).thenReturn(1L); when(mockList.getItems()).thenReturn(List.of(mockTodoItem)); when(todoListService.getTodoListById(anyLong())).thenReturn(mockList); mockMvc.perform(get(\"/list\")).andExpectAll( status().isOk(), content().contentTypeCompatibleWith(TEXT_HTML), content().encoding(UTF_8), content().string(containsString(\"Buy milk\")) ); } } Implement the actual controller in the production code: // Removed import statements for brevity @Controller public class TodoListController { private TodoListService todoListService; @Autowired public void setTodoListService(TodoListService todoListService) { this.todoListService = todoListService; } @GetMapping(\"/list\") public String showList(Model model) { List<TodoItem> todoItems = todoListService.getTodoItems(); model.add(\"todoList\", todoItems); return \"list\"; } } Do not forget to create the HTML view of the todo list. Create a new HTML view called list.html in templates directory at src/main/resources : <!doctype html> <html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\"> <head> <meta charset=\"utf-8\"/> <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"/> <link th:rel=\"stylesheet\" th:href=\"@{/webjars/bootstrap/5.1.3/dist/css/bootstrap.css}\"/> <title>Sitodo</title> </head> <body> <div class=\"container\"> <header class=\"d-flex flex-wrap justify-content-center py-3 mb-4 border-bottom\"> <span class=\"fs-4\">SITODO</span> </header> <table id=\"id_list_table\" class=\"table caption-top\"> <caption class=\"display-1\">Your Todo List</caption> <thead class=\"table-dark\"> <tr> <th scope=\"col\">ID</th> <th scope=\"col\">Title</th> <th scope=\"col\">Status</th> </tr> </thead> <tbody> <tr th:each=\"item : ${todoList}\"> <td th:text=\"${item.id}\">1</td> <td th:text=\"${item.title}\">Cook rice</td> <td th:text=\"${item.finished} ? 'Finished' : 'Not Finished'\">Not Finished</td> </tr> </tbody> </table> <form action=\"/list\" method=\"post\"> <input type=\"text\" id=\"id_new_item\" name=\"item_text\" placeholder=\"Enter an item\"/> <button type=\"submit\" class=\"btn btn-primary btn-sm\">Enter</button> </form> </div> <script th:src=\"@{/webjars/bootstrap/5.1.3/dist/js/bootstrap.bundle.js}\"></script> </body> </html> The HTML view example above requires the Bootstrap CSS framework . You can either include Bootstrap from a content delivery network (CDN), or add a new dependency in pom.xml that adds Bootstrap into the project. If you choose to update the project dependencies in pom.xml , use the following Maven dependency that includes Bootstrap: <dependency> <groupId>org.webjars.npm</groupId> <artifactId>bootstrap</artifactId> <version>5.1.3</version> </dependency>","title":"Back to Controller and View"},{"location":"bootcamp/day-1/basic-list/#complete-the-basic-functionality","text":"You have known the overall groundwork required to implement a feature in the TDD approach. The next task is to ensure the user can actually create a new todo item. Now try to work on your own. But do not worry, there will be hints on how to complete it. Your tasks are as follows: Add a new test case in TodoListControllerTest that verifies the correctness of incoming HTTP POST message. Try to figure out how to use MockMvc to simulate an HTTP POST message with a data payload (i.e. the new todo item submitted via an HTML form). Add a new method in TodoListController that handles incoming HTTP POST message containing the new todo item. Use @PostMapping annotation to designate the new method as the handler of an incoming HTTP POST message to /list path. You also need to add a parameter into the method, so you can obtain the new todo item in the HTTP POST message. Try to run the application from time to time. While having test suites that are executed by a test runner is important, do not forget to run the app manually and try using it as an actual user. You can run the app by executing main() method in SitodoApplication class, or by calling mvnw spring-boot:run Maven command. If you have finished, do not forget to save your latest work as a commit and push it to GitHub: git add <path to the changed files> git commit git push","title":"Complete the Basic Functionality"},{"location":"bootcamp/day-1/end-day-1/","text":"End of Day 1 Congratulations! You have reached the end of mandatory tasks for Day 1. Agenda for Day 2 You will continue work on the todo list app. You might have noticed that the current iteration of the app can only contain a single todo list. Tomorrow you will learn how to implement a multiple todo lists functionality and begin to refactor the current app to use PostgreSQL database. Additional Material: Functional Test The TDD approach that you learned from today's session is a TDD process that starts from the \"inside\" or the innermost layer of the application. We often call this approach \"inside-out TDD\". We start by developing \"unit test\" that tests each \"unit\" (function, class, method) independently. Afterward, we add tests that verify the integration of units, i.e. \"integration test\". And finally, we create tests that verify the correctness of the features in the application, i.e. \"functional test\". There is another TDD approach called \"outside-in TDD\". As you might have guessed, it started from the outermost layer of the application. We start by developing the functional tests. Since the initial implementation will fail due to the tests, we develop more tests in the lower layer of the application. Afterward, we began to develop the actual implementation to pass the tests. You can create a functional test by using a browser automation tool such as Selenium . To integrate Selenium with JUnit 5 test runner included in Spring Boot, you can use a test framework called Selenide . It provides higher-level abstraction to Selenium and improves the developer experience in setting up functional test. To include Selenide to the project, add the following dependency declaration into pom.xml : <dependency> <groupId>com.codeborne</groupId> <artifactId>selenide</artifactId> <version>6.7.4</version> <scope>test</scope> </dependency> An example of functional test: import org.junit.jupiter.api.DisplayName; import org.junit.jupiter.api.Test; import org.springframework.boot.test.context.SpringBootTest; import org.springframework.boot.test.web.server.LocalServerPort; import org.springframework.beans.factory.annotation.Value; import static org.junit.jupiter.api.Assertions.assertTrue; import static com.codeborne.selenide.Selenide.open; import static com.codeborne.selenide.Selenide.title; import static com.codeborne.selenide.Configuration.baseUrl; import static com.codeborne.selenide.Configuration.browser; import static com.codeborne.selenide.Configuration.headless; import static com.codeborne.selenide.Selenide.$; import static com.codeborne.selenide.Selenide.closeWebDriver; @SpringBootTest(webEnvironment = RANDOM_PORT) @DisplayName(\"Smoke Test\") class SmokeTest { @LocalServerPort protected int serverPort; @Value(\"${sitodo.baseUrl:http://localhost}\") private String testBaseUrl; @Test @DisplayName(\"Verify text in <title> tag\") void site_hasTitle() { browser = \"firefox\"; // Or your favourite browser baseUrl = String.format(\"%s:%d\", testBaseUrl, serverPort); open(\"/\"); assertTrue(title().contains(\"Sitodo\"), \"The browser title was: \" + title()); closeWebDriver(); } } The example above tries to verify if the title displayed on the Web browser contains \"Sitodo\" string. The test runner will open up a Web browser and instruct it to open the Web application at given URL (i.e. / ). The test runner then will query the state of Web browser when performing verification. If you are interested, you can try developing functional tests using Selenium & Selenide. Implement the tests that simulate user (and browser) actions when opening a todo list and submitting a new todo item!","title":"Recap"},{"location":"bootcamp/day-1/end-day-1/#end-of-day-1","text":"Congratulations! You have reached the end of mandatory tasks for Day 1.","title":"End of Day 1"},{"location":"bootcamp/day-1/end-day-1/#agenda-for-day-2","text":"You will continue work on the todo list app. You might have noticed that the current iteration of the app can only contain a single todo list. Tomorrow you will learn how to implement a multiple todo lists functionality and begin to refactor the current app to use PostgreSQL database.","title":"Agenda for Day 2"},{"location":"bootcamp/day-1/end-day-1/#additional-material-functional-test","text":"The TDD approach that you learned from today's session is a TDD process that starts from the \"inside\" or the innermost layer of the application. We often call this approach \"inside-out TDD\". We start by developing \"unit test\" that tests each \"unit\" (function, class, method) independently. Afterward, we add tests that verify the integration of units, i.e. \"integration test\". And finally, we create tests that verify the correctness of the features in the application, i.e. \"functional test\". There is another TDD approach called \"outside-in TDD\". As you might have guessed, it started from the outermost layer of the application. We start by developing the functional tests. Since the initial implementation will fail due to the tests, we develop more tests in the lower layer of the application. Afterward, we began to develop the actual implementation to pass the tests. You can create a functional test by using a browser automation tool such as Selenium . To integrate Selenium with JUnit 5 test runner included in Spring Boot, you can use a test framework called Selenide . It provides higher-level abstraction to Selenium and improves the developer experience in setting up functional test. To include Selenide to the project, add the following dependency declaration into pom.xml : <dependency> <groupId>com.codeborne</groupId> <artifactId>selenide</artifactId> <version>6.7.4</version> <scope>test</scope> </dependency> An example of functional test: import org.junit.jupiter.api.DisplayName; import org.junit.jupiter.api.Test; import org.springframework.boot.test.context.SpringBootTest; import org.springframework.boot.test.web.server.LocalServerPort; import org.springframework.beans.factory.annotation.Value; import static org.junit.jupiter.api.Assertions.assertTrue; import static com.codeborne.selenide.Selenide.open; import static com.codeborne.selenide.Selenide.title; import static com.codeborne.selenide.Configuration.baseUrl; import static com.codeborne.selenide.Configuration.browser; import static com.codeborne.selenide.Configuration.headless; import static com.codeborne.selenide.Selenide.$; import static com.codeborne.selenide.Selenide.closeWebDriver; @SpringBootTest(webEnvironment = RANDOM_PORT) @DisplayName(\"Smoke Test\") class SmokeTest { @LocalServerPort protected int serverPort; @Value(\"${sitodo.baseUrl:http://localhost}\") private String testBaseUrl; @Test @DisplayName(\"Verify text in <title> tag\") void site_hasTitle() { browser = \"firefox\"; // Or your favourite browser baseUrl = String.format(\"%s:%d\", testBaseUrl, serverPort); open(\"/\"); assertTrue(title().contains(\"Sitodo\"), \"The browser title was: \" + title()); closeWebDriver(); } } The example above tries to verify if the title displayed on the Web browser contains \"Sitodo\" string. The test runner will open up a Web browser and instruct it to open the Web application at given URL (i.e. / ). The test runner then will query the state of Web browser when performing verification. If you are interested, you can try developing functional tests using Selenium & Selenide. Implement the tests that simulate user (and browser) actions when opening a todo list and submitting a new todo item!","title":"Additional Material: Functional Test"},{"location":"bootcamp/day-1/hello-tdd/","text":"Hello, Test-Driven Development Let us start by creating a controller class named HelloController in src/main/java directory, specifically under the package that was initialised by Spring Initialzr: import org.springframework.web.bind.annotation.GetMapping; @Controller public class HelloController { @GetMapping(\"/hello\") public String showHello() { return \"\"; } } We left the implementation empty for now. This is called as stubbing or creating an empty implementation. If the return value of a method in a controller class is a string, then the framework expects the return value contains the name of a Web page template. Notice there are two directories in src directory: main and test . The main directory contains the actual code for implementing the application. We often call the actual code as the production code . In contrast, the test directory contains the code for testing the application. It is also known as the test code . My First Test Case Create a new class named HelloControllerTest in controller package of the test code. The class will contain one or more instance methods that will execute the test cases. Let us start with a test case that verifies showHello method uses a Web page template named hello . Create a method named showHello_ok in HelloControllerTest : import org.junit.jupiter.api.Test; import static org.junit.jupiter.api.Assertions.*; public class HelloControllerTest { @Test void showHello_ok() { // [Setup] HelloController helloController = new HelloController(); // [Exercise] String result = helloController.showHello(); // [Verify] assertEquals(\"hello\", result); // [Teardown] // Do nothing } } The method that implements a test case can be structured into four sections: Setup , Exercise , Verify , and Teardown sections. Run the test suite via the shortcut in the editor or use Maven command mvnw test . If you implement the method exactly as written in this document, the test case execution will fail. That is the way how test-driven development is conducted. We always (or, strive to) start with writing a test case that initially fails. Pass the First Test According to the first test case, it expects the controller to use a Web page template (or often called as \"view\") named hello to generate the HTML response. Therefore, if you want to make the test pass, you need to make an HTML view with the same name. Now, create a new HTML view in templates directory. The content can be empty, since we only want to make the test pass. But at least, write something in the HTML such as a \"Hello, World\" message. At this point, we can verify that the controller works fine as an independent unit. The implementation of showHello returns the correct string value as we expected. However, we still do not know if showHello will behave as intended when it has to handle an actual HTTP request. This is where we are going to test the implementation in a mock/simulated environment. Test in a Mock Environment We know that showHello is an HTTP request handler implemented in a controller. If we want to actually verify if the implementation is correct, we can test the implementation in a simulated Web server. Go back to the test code and update HelloControllerTest class with the following code snippet: // New imports import org.springframework.beans.factory.annotation.Autowired; import org.springframework.test.web.servlet.MockMvc; import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest; import static java.nio.charset.StandardCharsets.UTF_8; import static org.springframework.http.MediaType.TEXT_HTML; import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get; import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*; // New annotation @WebMvcTest(HelloController.class) class HelloControllerTest { // New instance variable @Autowired private MockMvc mockMvc; @Test void showHello_ok() { // Omitted for brevity } @Test void showHello_okResponse() throws Exception { mockMvc.perform(get(\"/hello\")).andExpectAll( status().isOk(), content().contentTypeCompatibleWith(TEXT_HTML), content().encoding(UTF_8), view().name(\"hello\") ); } } The addition of @WebMvcTest annotation will make the test suite to be executed by a test runner provided by Spring framework. It will build and run the production code in a simulated Web server. Hence, it is possible for the test cases to run against a running application. For example, the new test case above will use an instance of MockMvc , which automatically injected by the Spring framework during runtime, to send an HTTP GET request to /hello path in the application. Then, we try to verify the HTTP response given by the application. Try to run the test suite again, either via the shortcut in the IDE or mvnw test command in the shell. You will see that the test suite does not run instantly as they previously did. The test runner now runs the production code on a simulated server before executing the test cases. Once you have verified all test cases pass, save your work as a new Git commit and push it to GitHub: # Track all changes in both production and test codes git add src/test/java git add src/main/java # And commit the changes into a single commit git commit You have gone through a single TDD cycle. It starts with writing a test, followed by the implementation to make the test pass. We have not covered refactoring in a TDD cycle since the production code is still quite simple. In the next section, you will deploy the app to a Platform-as-a-Service provider and learn how to automate the deployment process. You will also see how to ensure that the test suite is always executed whenever you pushed commits to GitHub. Make sure you have created an account on Heroku before continuing to the next section.","title":"Hello, TDD"},{"location":"bootcamp/day-1/hello-tdd/#hello-test-driven-development","text":"Let us start by creating a controller class named HelloController in src/main/java directory, specifically under the package that was initialised by Spring Initialzr: import org.springframework.web.bind.annotation.GetMapping; @Controller public class HelloController { @GetMapping(\"/hello\") public String showHello() { return \"\"; } } We left the implementation empty for now. This is called as stubbing or creating an empty implementation. If the return value of a method in a controller class is a string, then the framework expects the return value contains the name of a Web page template. Notice there are two directories in src directory: main and test . The main directory contains the actual code for implementing the application. We often call the actual code as the production code . In contrast, the test directory contains the code for testing the application. It is also known as the test code .","title":"Hello, Test-Driven Development"},{"location":"bootcamp/day-1/hello-tdd/#my-first-test-case","text":"Create a new class named HelloControllerTest in controller package of the test code. The class will contain one or more instance methods that will execute the test cases. Let us start with a test case that verifies showHello method uses a Web page template named hello . Create a method named showHello_ok in HelloControllerTest : import org.junit.jupiter.api.Test; import static org.junit.jupiter.api.Assertions.*; public class HelloControllerTest { @Test void showHello_ok() { // [Setup] HelloController helloController = new HelloController(); // [Exercise] String result = helloController.showHello(); // [Verify] assertEquals(\"hello\", result); // [Teardown] // Do nothing } } The method that implements a test case can be structured into four sections: Setup , Exercise , Verify , and Teardown sections. Run the test suite via the shortcut in the editor or use Maven command mvnw test . If you implement the method exactly as written in this document, the test case execution will fail. That is the way how test-driven development is conducted. We always (or, strive to) start with writing a test case that initially fails.","title":"My First Test Case"},{"location":"bootcamp/day-1/hello-tdd/#pass-the-first-test","text":"According to the first test case, it expects the controller to use a Web page template (or often called as \"view\") named hello to generate the HTML response. Therefore, if you want to make the test pass, you need to make an HTML view with the same name. Now, create a new HTML view in templates directory. The content can be empty, since we only want to make the test pass. But at least, write something in the HTML such as a \"Hello, World\" message. At this point, we can verify that the controller works fine as an independent unit. The implementation of showHello returns the correct string value as we expected. However, we still do not know if showHello will behave as intended when it has to handle an actual HTTP request. This is where we are going to test the implementation in a mock/simulated environment.","title":"Pass the First Test"},{"location":"bootcamp/day-1/hello-tdd/#test-in-a-mock-environment","text":"We know that showHello is an HTTP request handler implemented in a controller. If we want to actually verify if the implementation is correct, we can test the implementation in a simulated Web server. Go back to the test code and update HelloControllerTest class with the following code snippet: // New imports import org.springframework.beans.factory.annotation.Autowired; import org.springframework.test.web.servlet.MockMvc; import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest; import static java.nio.charset.StandardCharsets.UTF_8; import static org.springframework.http.MediaType.TEXT_HTML; import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get; import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*; // New annotation @WebMvcTest(HelloController.class) class HelloControllerTest { // New instance variable @Autowired private MockMvc mockMvc; @Test void showHello_ok() { // Omitted for brevity } @Test void showHello_okResponse() throws Exception { mockMvc.perform(get(\"/hello\")).andExpectAll( status().isOk(), content().contentTypeCompatibleWith(TEXT_HTML), content().encoding(UTF_8), view().name(\"hello\") ); } } The addition of @WebMvcTest annotation will make the test suite to be executed by a test runner provided by Spring framework. It will build and run the production code in a simulated Web server. Hence, it is possible for the test cases to run against a running application. For example, the new test case above will use an instance of MockMvc , which automatically injected by the Spring framework during runtime, to send an HTTP GET request to /hello path in the application. Then, we try to verify the HTTP response given by the application. Try to run the test suite again, either via the shortcut in the IDE or mvnw test command in the shell. You will see that the test suite does not run instantly as they previously did. The test runner now runs the production code on a simulated server before executing the test cases. Once you have verified all test cases pass, save your work as a new Git commit and push it to GitHub: # Track all changes in both production and test codes git add src/test/java git add src/main/java # And commit the changes into a single commit git commit You have gone through a single TDD cycle. It starts with writing a test, followed by the implementation to make the test pass. We have not covered refactoring in a TDD cycle since the production code is still quite simple. In the next section, you will deploy the app to a Platform-as-a-Service provider and learn how to automate the deployment process. You will also see how to ensure that the test suite is always executed whenever you pushed commits to GitHub. Make sure you have created an account on Heroku before continuing to the next section.","title":"Test in a Mock Environment"},{"location":"bootcamp/day-1/init-spring/","text":"Project Initialisation Go to Spring Initializr . Initialise a Spring Boot Project Choose the following options: Maven project Java language Spring Boot version 2.7.4 (the latest stable version at the time of writing) Write the name of the base Java package in the group field. The name should follow the reverse-order domain naming scheme. Usually, the name is based on the actual domain name of a company. For example, if you work on a company called Example and the domain name is example.com , then the reverse-order name is com.example . Write the name of the application in the artifact and name fields. Make sure the name starts with an alphabet symbol and does not contain a hyphen (e.g. - ). Provide a short description of the project in the description field. Package name field should not be modified since it is generated from the values set in group and artifact fields. For example, if the group is set to com.example and artifact is set to sitodo , then the generated name will be com.example.sitodo . Choose Java version 17 because it is the LTS (long-term support) version at the time of writing. Include the following dependencies as well: Lombok Spring Web Thymeleaf Spring Data JPA H2 Database The final options should be similar to the following screenshot: Generate and download the base code as a ZIP file by clicking the Generate button. Extract the downloaded ZIP file into a directory of your choice. For example, if you extract the ZIP file into the home directory of your operating system (OS), there would be a new directory containing the source code at the following path: GNU/Linux-based OS (e.g. Debian, Ubuntu): /home/MyAccount/sitodo Windows: C:\\Users\\MyAccount\\sitodo Open a (terminal) shell in your OS and go to the project directory: cd <path to the project directory> Use provided Maven wrapper ( mvnw ) in the project directory to build the project using package command: ./mvnw package If everything goes well, you will see a new directory named output that contains a JAR file. Since we have verified that the project can be built successfully, clean up the build artifacts using mvnw clean command: ./mvnw clean Initialise a Local Git Repository Initialise the current working directory where the project was extracted as a new Git repository: git init -b main . Configure the local repository to use your credentials on GitHub: git config user.name \"<Full Name>\" git config user.email \"<Email Address>\" Add all files into Git and save it as a new commit: git add . git commit Create an Online Git Repository on GitHub Go to GitHub and create a new repository. You can name it anything, but try to make it descriptive. For the purpose of the bootcamp, you can name your new repository as \"Sitodo\". Once you created the new repository, take note of its clone URL on GitHub. Pick the HTTPS clone URL if you are new to Git and GitHub. Then, go back to your shell and add a new remote called origin using git command: git remote add origin <URL to the remote repository> Then push the commit from the main branch (i.e. the default branch in your local Git repository) to GitHub: git push origin main Open GitHub page of your repository and see if the source code has been pushed successfully. Now let us move on to the next part of the course, which is to get introduced with test-driven development.","title":"Initialise Project"},{"location":"bootcamp/day-1/init-spring/#project-initialisation","text":"Go to Spring Initializr .","title":"Project Initialisation"},{"location":"bootcamp/day-1/init-spring/#initialise-a-spring-boot-project","text":"Choose the following options: Maven project Java language Spring Boot version 2.7.4 (the latest stable version at the time of writing) Write the name of the base Java package in the group field. The name should follow the reverse-order domain naming scheme. Usually, the name is based on the actual domain name of a company. For example, if you work on a company called Example and the domain name is example.com , then the reverse-order name is com.example . Write the name of the application in the artifact and name fields. Make sure the name starts with an alphabet symbol and does not contain a hyphen (e.g. - ). Provide a short description of the project in the description field. Package name field should not be modified since it is generated from the values set in group and artifact fields. For example, if the group is set to com.example and artifact is set to sitodo , then the generated name will be com.example.sitodo . Choose Java version 17 because it is the LTS (long-term support) version at the time of writing. Include the following dependencies as well: Lombok Spring Web Thymeleaf Spring Data JPA H2 Database The final options should be similar to the following screenshot: Generate and download the base code as a ZIP file by clicking the Generate button. Extract the downloaded ZIP file into a directory of your choice. For example, if you extract the ZIP file into the home directory of your operating system (OS), there would be a new directory containing the source code at the following path: GNU/Linux-based OS (e.g. Debian, Ubuntu): /home/MyAccount/sitodo Windows: C:\\Users\\MyAccount\\sitodo Open a (terminal) shell in your OS and go to the project directory: cd <path to the project directory> Use provided Maven wrapper ( mvnw ) in the project directory to build the project using package command: ./mvnw package If everything goes well, you will see a new directory named output that contains a JAR file. Since we have verified that the project can be built successfully, clean up the build artifacts using mvnw clean command: ./mvnw clean","title":"Initialise a Spring Boot Project"},{"location":"bootcamp/day-1/init-spring/#initialise-a-local-git-repository","text":"Initialise the current working directory where the project was extracted as a new Git repository: git init -b main . Configure the local repository to use your credentials on GitHub: git config user.name \"<Full Name>\" git config user.email \"<Email Address>\" Add all files into Git and save it as a new commit: git add . git commit","title":"Initialise a Local Git Repository"},{"location":"bootcamp/day-1/init-spring/#create-an-online-git-repository-on-github","text":"Go to GitHub and create a new repository. You can name it anything, but try to make it descriptive. For the purpose of the bootcamp, you can name your new repository as \"Sitodo\". Once you created the new repository, take note of its clone URL on GitHub. Pick the HTTPS clone URL if you are new to Git and GitHub. Then, go back to your shell and add a new remote called origin using git command: git remote add origin <URL to the remote repository> Then push the commit from the main branch (i.e. the default branch in your local Git repository) to GitHub: git push origin main Open GitHub page of your repository and see if the source code has been pushed successfully. Now let us move on to the next part of the course, which is to get introduced with test-driven development.","title":"Create an Online Git Repository on GitHub"},{"location":"bootcamp/day-1/qa-automation/","text":"Quality Assurance & Automation In order to make the production code can be built and deployed on Heroku, we have to follow the rules dictated by the service provider (i.e. Heroku). Create a new file called Procfile in the root project directory. It defines one or more processes that can run on Heroku's environment. For our purpose today, you only need to define a single process called web that runs the application. The content can be seen in the following snippet: web: java -Dserver.port=$PORT $JAVA_OPTS -jar target/*.jar You also need to create a new file named system.properties in the root project directory. It will be used to bind a specific version of Java to the deployment environment. The content can be seen in the following snippet: java.runtime.version=17 Add new files into local Git history and push the commit to GitHub: git add Procfile system.properties git commit git push origin main Setting Up GitHub Actions At this point, the app will not deploy because we have not configured the CI/CD tools provided by GitHub.","title":"Automation"},{"location":"bootcamp/day-1/qa-automation/#quality-assurance-automation","text":"In order to make the production code can be built and deployed on Heroku, we have to follow the rules dictated by the service provider (i.e. Heroku). Create a new file called Procfile in the root project directory. It defines one or more processes that can run on Heroku's environment. For our purpose today, you only need to define a single process called web that runs the application. The content can be seen in the following snippet: web: java -Dserver.port=$PORT $JAVA_OPTS -jar target/*.jar You also need to create a new file named system.properties in the root project directory. It will be used to bind a specific version of Java to the deployment environment. The content can be seen in the following snippet: java.runtime.version=17 Add new files into local Git history and push the commit to GitHub: git add Procfile system.properties git commit git push origin main","title":"Quality Assurance &amp; Automation"},{"location":"bootcamp/day-1/qa-automation/#setting-up-github-actions","text":"At this point, the app will not deploy because we have not configured the CI/CD tools provided by GitHub.","title":"Setting Up GitHub Actions"},{"location":"bootcamp/day-2/","text":"Bootcamp (Day 2) Still in development. Stay tune!","title":"TBD"},{"location":"bootcamp/day-2/#bootcamp-day-2","text":"Still in development. Stay tune!","title":"Bootcamp (Day 2)"}]}